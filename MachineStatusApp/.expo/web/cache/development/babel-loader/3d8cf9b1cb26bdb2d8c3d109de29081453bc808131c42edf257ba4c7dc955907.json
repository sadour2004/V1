{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasComponentStack = hasComponentStack;\nexports.parseComponentStack = parseComponentStack;\nexports.parseInterpolation = parseInterpolation;\nexports.parseLogBoxException = parseLogBoxException;\nexports.parseLogBoxLog = parseLogBoxLog;\nexports.withoutANSIColorStyles = withoutANSIColorStyles;\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _parseErrorStack = _interopRequireDefault(require(\"../../Core/Devtools/parseErrorStack\"));\nvar _UTFSequence = _interopRequireDefault(require(\"../../UTFSequence\"));\nvar _stringifySafe = _interopRequireDefault(require(\"../../Utilities/stringifySafe\"));\nvar _ansiRegex = _interopRequireDefault(require(\"ansi-regex\"));\nvar ANSI_REGEX = (0, _ansiRegex.default)().source;\nvar RE_TRANSFORM_ERROR = /^TransformError /;\nvar RE_COMPONENT_STACK_LINE = /\\n {4}(in|at) /;\nvar RE_COMPONENT_STACK_LINE_GLOBAL = /\\n {4}(in|at) /g;\nvar RE_COMPONENT_STACK_LINE_OLD = / {4}in/;\nvar RE_COMPONENT_STACK_LINE_NEW = / {4}at/;\nvar RE_COMPONENT_STACK_LINE_STACK_FRAME = /@.*\\n/;\nvar RE_BABEL_TRANSFORM_ERROR_FORMAT = /^(?:TransformError )?(?:SyntaxError: |ReferenceError: )(.*): (.*) \\((\\d+):(\\d+)\\)\\n\\n([\\s\\S]+)/;\nvar RE_COMPONENT_STACK_WITH_SOURCE = /(.*) \\(at (.*\\.(?:js|jsx|ts|tsx)):([\\d]+)\\)/;\nvar RE_COMPONENT_STACK_NO_SOURCE = /(.*) \\(created by .*\\)/;\nvar RE_BABEL_CODE_FRAME_ERROR_FORMAT = /^(?:TransformError )?(?:(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*):? (?:(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*?)(\\/(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*): ((?:[\\0-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF])+?)\\n([ >]{2}[\\t-\\r 0-9\\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]+ \\|(?:[\\0-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF])+|\\x1B(?:[\\0-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF])+)/;\nvar RE_METRO_ERROR_FORMAT = /^(?:InternalError Metro has encountered an error:) ((?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*): ((?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*) \\(([0-9]+):([0-9]+)\\)\\n\\n((?:[\\0-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF])+)/;\nvar RE_BABEL_CODE_FRAME_MARKER_PATTERN = new RegExp(['^', `(?:${ANSI_REGEX})*`, '>', `(?:${ANSI_REGEX})*`, ' +', '[0-9]+', ' \\\\|'].join(''), 'm');\nfunction hasComponentStack(args) {\n  for (var arg of args) {\n    if (typeof arg === 'string' && isComponentStack(arg)) {\n      return true;\n    }\n  }\n  return false;\n}\nvar SUBSTITUTION = _UTFSequence.default.BOM + '%s';\nfunction parseInterpolation(args) {\n  var categoryParts = [];\n  var contentParts = [];\n  var substitutionOffsets = [];\n  var remaining = (0, _toConsumableArray2.default)(args);\n  if (typeof remaining[0] === 'string') {\n    var formatString = String(remaining.shift());\n    var formatStringParts = formatString.split('%s');\n    var substitutionCount = formatStringParts.length - 1;\n    var substitutions = remaining.splice(0, substitutionCount);\n    var categoryString = '';\n    var contentString = '';\n    var substitutionIndex = 0;\n    for (var formatStringPart of formatStringParts) {\n      categoryString += formatStringPart;\n      contentString += formatStringPart;\n      if (substitutionIndex < substitutionCount) {\n        if (substitutionIndex < substitutions.length) {\n          var substitution = typeof substitutions[substitutionIndex] === 'string' ? substitutions[substitutionIndex] : (0, _stringifySafe.default)(substitutions[substitutionIndex]);\n          substitutionOffsets.push({\n            length: substitution.length,\n            offset: contentString.length\n          });\n          categoryString += SUBSTITUTION;\n          contentString += substitution;\n        } else {\n          substitutionOffsets.push({\n            length: 2,\n            offset: contentString.length\n          });\n          categoryString += '%s';\n          contentString += '%s';\n        }\n        substitutionIndex++;\n      }\n    }\n    categoryParts.push(categoryString);\n    contentParts.push(contentString);\n  }\n  var remainingArgs = remaining.map(function (arg) {\n    return typeof arg === 'string' ? arg : (0, _stringifySafe.default)(arg);\n  });\n  categoryParts.push.apply(categoryParts, (0, _toConsumableArray2.default)(remainingArgs));\n  contentParts.push.apply(contentParts, (0, _toConsumableArray2.default)(remainingArgs));\n  return {\n    category: categoryParts.join(' '),\n    message: {\n      content: contentParts.join(' '),\n      substitutions: substitutionOffsets\n    }\n  };\n}\nfunction isComponentStack(consoleArgument) {\n  var isOldComponentStackFormat = RE_COMPONENT_STACK_LINE_OLD.test(consoleArgument);\n  var isNewComponentStackFormat = RE_COMPONENT_STACK_LINE_NEW.test(consoleArgument);\n  var isNewJSCComponentStackFormat = RE_COMPONENT_STACK_LINE_STACK_FRAME.test(consoleArgument);\n  return isOldComponentStackFormat || isNewComponentStackFormat || isNewJSCComponentStackFormat;\n}\nfunction parseComponentStack(message) {\n  var stack = (0, _parseErrorStack.default)(message);\n  if (stack && stack.length > 0) {\n    return {\n      type: 'stack',\n      stack: stack.map(function (frame) {\n        return {\n          content: frame.methodName,\n          collapse: frame.collapse || false,\n          fileName: frame.file == null ? 'unknown' : frame.file,\n          location: {\n            column: frame.column == null ? -1 : frame.column,\n            row: frame.lineNumber == null ? -1 : frame.lineNumber\n          }\n        };\n      })\n    };\n  }\n  var legacyStack = message.split(RE_COMPONENT_STACK_LINE_GLOBAL).map(function (s) {\n    if (!s) {\n      return null;\n    }\n    var match = s.match(RE_COMPONENT_STACK_WITH_SOURCE);\n    if (match) {\n      var _match$slice = match.slice(1),\n        _match$slice2 = (0, _slicedToArray2.default)(_match$slice, 3),\n        content = _match$slice2[0],\n        fileName = _match$slice2[1],\n        row = _match$slice2[2];\n      return {\n        content: content,\n        fileName: fileName,\n        location: {\n          column: -1,\n          row: parseInt(row, 10)\n        }\n      };\n    }\n    var matchWithoutSource = s.match(RE_COMPONENT_STACK_NO_SOURCE);\n    if (matchWithoutSource) {\n      return {\n        content: matchWithoutSource[1],\n        fileName: '',\n        location: null\n      };\n    }\n    return null;\n  }).filter(Boolean);\n  return {\n    type: 'legacy',\n    stack: legacyStack\n  };\n}\nfunction parseLogBoxException(error) {\n  var message = error.originalMessage != null ? error.originalMessage : 'Unknown';\n  var metroInternalError = message.match(RE_METRO_ERROR_FORMAT);\n  if (metroInternalError) {\n    var _metroInternalError$s = metroInternalError.slice(1),\n      _metroInternalError$s2 = (0, _slicedToArray2.default)(_metroInternalError$s, 5),\n      content = _metroInternalError$s2[0],\n      fileName = _metroInternalError$s2[1],\n      row = _metroInternalError$s2[2],\n      column = _metroInternalError$s2[3],\n      codeFrame = _metroInternalError$s2[4];\n    return {\n      level: 'fatal',\n      type: 'Metro Error',\n      stack: [],\n      isComponentError: false,\n      componentStackType: 'legacy',\n      componentStack: [],\n      codeFrame: {\n        fileName: fileName,\n        location: {\n          row: parseInt(row, 10),\n          column: parseInt(column, 10)\n        },\n        content: codeFrame\n      },\n      message: {\n        content: content,\n        substitutions: []\n      },\n      category: `${fileName}-${row}-${column}`,\n      extraData: error.extraData\n    };\n  }\n  var babelTransformError = message.match(RE_BABEL_TRANSFORM_ERROR_FORMAT);\n  if (babelTransformError) {\n    var _babelTransformError$ = babelTransformError.slice(1),\n      _babelTransformError$2 = (0, _slicedToArray2.default)(_babelTransformError$, 5),\n      _fileName = _babelTransformError$2[0],\n      _content = _babelTransformError$2[1],\n      _row = _babelTransformError$2[2],\n      _column = _babelTransformError$2[3],\n      _codeFrame = _babelTransformError$2[4];\n    return {\n      level: 'syntax',\n      stack: [],\n      isComponentError: false,\n      componentStackType: 'legacy',\n      componentStack: [],\n      codeFrame: {\n        fileName: _fileName,\n        location: {\n          row: parseInt(_row, 10),\n          column: parseInt(_column, 10)\n        },\n        content: _codeFrame\n      },\n      message: {\n        content: _content,\n        substitutions: []\n      },\n      category: `${_fileName}-${_row}-${_column}`,\n      extraData: error.extraData\n    };\n  }\n  if (RE_BABEL_CODE_FRAME_MARKER_PATTERN.test(message)) {\n    var babelCodeFrameError = message.match(RE_BABEL_CODE_FRAME_ERROR_FORMAT);\n    if (babelCodeFrameError) {\n      var _babelCodeFrameError$ = babelCodeFrameError.slice(1),\n        _babelCodeFrameError$2 = (0, _slicedToArray2.default)(_babelCodeFrameError$, 3),\n        _fileName2 = _babelCodeFrameError$2[0],\n        _content2 = _babelCodeFrameError$2[1],\n        _codeFrame2 = _babelCodeFrameError$2[2];\n      return {\n        level: 'syntax',\n        stack: [],\n        isComponentError: false,\n        componentStackType: 'legacy',\n        componentStack: [],\n        codeFrame: {\n          fileName: _fileName2,\n          location: null,\n          content: _codeFrame2\n        },\n        message: {\n          content: _content2,\n          substitutions: []\n        },\n        category: `${_fileName2}-${1}-${1}`,\n        extraData: error.extraData\n      };\n    }\n  }\n  if (message.match(RE_TRANSFORM_ERROR)) {\n    return {\n      level: 'syntax',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStackType: 'legacy',\n      componentStack: [],\n      message: {\n        content: message,\n        substitutions: []\n      },\n      category: message,\n      extraData: error.extraData\n    };\n  }\n  var componentStack = error.componentStack;\n  if (error.isFatal || error.isComponentError) {\n    if (componentStack != null) {\n      var _parseComponentStack = parseComponentStack(componentStack),\n        type = _parseComponentStack.type,\n        stack = _parseComponentStack.stack;\n      return Object.assign({\n        level: 'fatal',\n        stack: error.stack,\n        isComponentError: error.isComponentError,\n        componentStackType: type,\n        componentStack: stack,\n        extraData: error.extraData\n      }, parseInterpolation([message]));\n    } else {\n      return Object.assign({\n        level: 'fatal',\n        stack: error.stack,\n        isComponentError: error.isComponentError,\n        componentStackType: 'legacy',\n        componentStack: [],\n        extraData: error.extraData\n      }, parseInterpolation([message]));\n    }\n  }\n  if (componentStack != null) {\n    var _parseComponentStack2 = parseComponentStack(componentStack),\n      _type = _parseComponentStack2.type,\n      _stack = _parseComponentStack2.stack;\n    return Object.assign({\n      level: 'error',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStackType: _type,\n      componentStack: _stack,\n      extraData: error.extraData\n    }, parseInterpolation([message]));\n  }\n  return Object.assign({\n    level: 'error',\n    stack: error.stack,\n    isComponentError: error.isComponentError,\n    extraData: error.extraData\n  }, parseLogBoxLog([message]));\n}\nfunction withoutANSIColorStyles(message) {\n  if (typeof message !== 'string') {\n    return message;\n  }\n  return message.replace(/[\\u001b\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '');\n}\nfunction parseLogBoxLog(args) {\n  var message = withoutANSIColorStyles(args[0]);\n  var argsWithoutComponentStack = [];\n  var componentStack = [];\n  var componentStackType = 'legacy';\n  if (typeof message === 'string' && message.slice(-2) === '%s' && args.length > 0) {\n    var lastArg = args[args.length - 1];\n    if (typeof lastArg === 'string' && isComponentStack(lastArg)) {\n      argsWithoutComponentStack = args.slice(0, -1);\n      argsWithoutComponentStack[0] = message.slice(0, -2);\n      var _parseComponentStack3 = parseComponentStack(lastArg),\n        type = _parseComponentStack3.type,\n        stack = _parseComponentStack3.stack;\n      componentStack = stack;\n      componentStackType = type;\n    }\n  }\n  if (componentStack.length === 0 && argsWithoutComponentStack.length === 0) {\n    for (var arg of args) {\n      if (typeof arg === 'string' && isComponentStack(arg)) {\n        var messageEndIndex = arg.search(RE_COMPONENT_STACK_LINE);\n        if (messageEndIndex < 0) {\n          messageEndIndex = arg.search(/\\n/);\n        }\n        if (messageEndIndex > 0) {\n          argsWithoutComponentStack.push(arg.slice(0, messageEndIndex));\n        }\n        var _parseComponentStack4 = parseComponentStack(arg),\n          _type2 = _parseComponentStack4.type,\n          _stack2 = _parseComponentStack4.stack;\n        componentStack = _stack2;\n        componentStackType = _type2;\n      } else {\n        argsWithoutComponentStack.push(arg);\n      }\n    }\n  }\n  return Object.assign({}, parseInterpolation(argsWithoutComponentStack), {\n    componentStack: componentStack,\n    componentStackType: componentStackType\n  });\n}","map":{"version":3,"names":["_parseErrorStack","_interopRequireDefault","require","_UTFSequence","_stringifySafe","_ansiRegex","ANSI_REGEX","ansiRegex","source","RE_TRANSFORM_ERROR","RE_COMPONENT_STACK_LINE","RE_COMPONENT_STACK_LINE_GLOBAL","RE_COMPONENT_STACK_LINE_OLD","RE_COMPONENT_STACK_LINE_NEW","RE_COMPONENT_STACK_LINE_STACK_FRAME","RE_BABEL_TRANSFORM_ERROR_FORMAT","RE_COMPONENT_STACK_WITH_SOURCE","RE_COMPONENT_STACK_NO_SOURCE","RE_BABEL_CODE_FRAME_ERROR_FORMAT","RE_METRO_ERROR_FORMAT","RE_BABEL_CODE_FRAME_MARKER_PATTERN","RegExp","join","hasComponentStack","args","arg","isComponentStack","SUBSTITUTION","UTFSequence","BOM","parseInterpolation","categoryParts","contentParts","substitutionOffsets","remaining","_toConsumableArray2","default","formatString","String","shift","formatStringParts","split","substitutionCount","length","substitutions","splice","categoryString","contentString","substitutionIndex","formatStringPart","substitution","stringifySafe","push","offset","remainingArgs","map","apply","category","message","content","consoleArgument","isOldComponentStackFormat","test","isNewComponentStackFormat","isNewJSCComponentStackFormat","parseComponentStack","stack","parseErrorStack","type","frame","methodName","collapse","fileName","file","location","column","row","lineNumber","legacyStack","s","match","_match$slice","slice","_match$slice2","_slicedToArray2","parseInt","matchWithoutSource","filter","Boolean","parseLogBoxException","error","originalMessage","metroInternalError","_metroInternalError$s","_metroInternalError$s2","codeFrame","level","isComponentError","componentStackType","componentStack","extraData","babelTransformError","_babelTransformError$","_babelTransformError$2","babelCodeFrameError","_babelCodeFrameError$","_babelCodeFrameError$2","isFatal","_parseComponentStack","Object","assign","_parseComponentStack2","parseLogBoxLog","withoutANSIColorStyles","replace","argsWithoutComponentStack","lastArg","_parseComponentStack3","messageEndIndex","search","_parseComponentStack4"],"sources":["/Users/ayoubsadour/Desktop/APPMOBILE/MachineStatusApp/node_modules/react-native/Libraries/LogBox/Data/parseLogBoxLog.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\nimport type {ExceptionData} from '../../Core/NativeExceptionsManager';\nimport type {LogBoxLogData} from './LogBoxLog';\n\nimport parseErrorStack from '../../Core/Devtools/parseErrorStack';\nimport UTFSequence from '../../UTFSequence';\nimport stringifySafe from '../../Utilities/stringifySafe';\nimport ansiRegex from 'ansi-regex';\n\nconst ANSI_REGEX = ansiRegex().source;\n\nconst RE_TRANSFORM_ERROR = /^TransformError /;\nconst RE_COMPONENT_STACK_LINE = /\\n {4}(in|at) /;\nconst RE_COMPONENT_STACK_LINE_GLOBAL = /\\n {4}(in|at) /g;\nconst RE_COMPONENT_STACK_LINE_OLD = / {4}in/;\nconst RE_COMPONENT_STACK_LINE_NEW = / {4}at/;\nconst RE_COMPONENT_STACK_LINE_STACK_FRAME = /@.*\\n/;\n\n// \"TransformError \" (Optional) and either \"SyntaxError: \" or \"ReferenceError: \"\n// Capturing groups:\n// 1: error message\n// 2: file path\n// 3: line number\n// 4: column number\n// \\n\\n\n// 5: code frame\nconst RE_BABEL_TRANSFORM_ERROR_FORMAT =\n  /^(?:TransformError )?(?:SyntaxError: |ReferenceError: )(.*): (.*) \\((\\d+):(\\d+)\\)\\n\\n([\\s\\S]+)/;\n\n// Capturing groups:\n// 1: component name\n// \"at\"\n// 2: file path including extension\n// 3: line number\nconst RE_COMPONENT_STACK_WITH_SOURCE =\n  /(.*) \\(at (.*\\.(?:js|jsx|ts|tsx)):([\\d]+)\\)/;\n\n// Capturing groups:\n// 1: component name\n// \"at\"\n// 2: parent component name\nconst RE_COMPONENT_STACK_NO_SOURCE = /(.*) \\(created by .*\\)/;\n\n// Capturing groups:\n// - non-capturing \"TransformError \" (optional)\n// - non-capturing Error message\n// 1: file path\n// 2: file name\n// 3: error message\n// 4: code frame, which includes code snippet indicators or terminal escape sequences for formatting.\nconst RE_BABEL_CODE_FRAME_ERROR_FORMAT =\n  // eslint-disable-next-line no-control-regex\n  /^(?:TransformError )?(?:.*):? (?:.*?)(\\/.*): ([\\s\\S]+?)\\n([ >]{2}[\\d\\s]+ \\|[\\s\\S]+|\\u{001b}[\\s\\S]+)/u;\n\n// Capturing groups:\n// - non-capturing \"InternalError Metro has encountered an error:\"\n// 1: error title\n// 2: error message\n// 3: file path\n// 4: line number\n// 5: column number\n// 6: code frame, which includes code snippet indicators or terminal escape sequences for formatting.\nconst RE_METRO_ERROR_FORMAT =\n  /^(?:InternalError Metro has encountered an error:) (.*): (.*) \\((\\d+):(\\d+)\\)\\n\\n([\\s\\S]+)/u;\n\n// https://github.com/babel/babel/blob/33dbb85e9e9fe36915273080ecc42aee62ed0ade/packages/babel-code-frame/src/index.ts#L183-L184\nconst RE_BABEL_CODE_FRAME_MARKER_PATTERN = new RegExp(\n  [\n    // Beginning of a line (per 'm' flag)\n    '^',\n    // Optional ANSI escapes for colors\n    `(?:${ANSI_REGEX})*`,\n    // Marker\n    '>',\n    // Optional ANSI escapes for colors\n    `(?:${ANSI_REGEX})*`,\n    // Left padding for line number\n    ' +',\n    // Line number\n    '[0-9]+',\n    // Gutter\n    ' \\\\|',\n  ].join(''),\n  'm',\n);\n\nexport function hasComponentStack(args: $ReadOnlyArray<mixed>): boolean {\n  for (const arg of args) {\n    if (typeof arg === 'string' && isComponentStack(arg)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport type ExtendedExceptionData = ExceptionData & {\n  isComponentError: boolean,\n  ...\n};\nexport type Category = string;\nexport type CodeFrame = $ReadOnly<{\n  content: string,\n  location: ?{\n    row: number,\n    column: number,\n    ...\n  },\n  fileName: string,\n\n  // TODO: When React switched to using call stack frames,\n  // we gained the ability to use the collapse flag, but\n  // it is not integrated into the LogBox UI.\n  collapse?: boolean,\n}>;\nexport type Message = $ReadOnly<{\n  content: string,\n  substitutions: $ReadOnlyArray<\n    $ReadOnly<{\n      length: number,\n      offset: number,\n    }>,\n  >,\n}>;\n\nexport type ComponentStack = $ReadOnlyArray<CodeFrame>;\nexport type ComponentStackType = 'legacy' | 'stack';\n\nconst SUBSTITUTION = UTFSequence.BOM + '%s';\n\nexport function parseInterpolation(args: $ReadOnlyArray<mixed>): $ReadOnly<{\n  category: Category,\n  message: Message,\n}> {\n  const categoryParts = [];\n  const contentParts = [];\n  const substitutionOffsets = [];\n\n  const remaining = [...args];\n  if (typeof remaining[0] === 'string') {\n    const formatString = String(remaining.shift());\n    const formatStringParts = formatString.split('%s');\n    const substitutionCount = formatStringParts.length - 1;\n    const substitutions = remaining.splice(0, substitutionCount);\n\n    let categoryString = '';\n    let contentString = '';\n\n    let substitutionIndex = 0;\n    for (const formatStringPart of formatStringParts) {\n      categoryString += formatStringPart;\n      contentString += formatStringPart;\n\n      if (substitutionIndex < substitutionCount) {\n        if (substitutionIndex < substitutions.length) {\n          // Don't stringify a string type.\n          // It adds quotation mark wrappers around the string,\n          // which causes the LogBox to look odd.\n          const substitution =\n            typeof substitutions[substitutionIndex] === 'string'\n              ? substitutions[substitutionIndex]\n              : stringifySafe(substitutions[substitutionIndex]);\n          substitutionOffsets.push({\n            length: substitution.length,\n            offset: contentString.length,\n          });\n\n          categoryString += SUBSTITUTION;\n          contentString += substitution;\n        } else {\n          substitutionOffsets.push({\n            length: 2,\n            offset: contentString.length,\n          });\n\n          categoryString += '%s';\n          contentString += '%s';\n        }\n\n        substitutionIndex++;\n      }\n    }\n\n    categoryParts.push(categoryString);\n    contentParts.push(contentString);\n  }\n\n  const remainingArgs = remaining.map(arg => {\n    // Don't stringify a string type.\n    // It adds quotation mark wrappers around the string,\n    // which causes the LogBox to look odd.\n    return typeof arg === 'string' ? arg : stringifySafe(arg);\n  });\n  categoryParts.push(...remainingArgs);\n  contentParts.push(...remainingArgs);\n\n  return {\n    category: categoryParts.join(' '),\n    message: {\n      content: contentParts.join(' '),\n      substitutions: substitutionOffsets,\n    },\n  };\n}\n\nfunction isComponentStack(consoleArgument: string) {\n  const isOldComponentStackFormat =\n    RE_COMPONENT_STACK_LINE_OLD.test(consoleArgument);\n  const isNewComponentStackFormat =\n    RE_COMPONENT_STACK_LINE_NEW.test(consoleArgument);\n  const isNewJSCComponentStackFormat =\n    RE_COMPONENT_STACK_LINE_STACK_FRAME.test(consoleArgument);\n\n  return (\n    isOldComponentStackFormat ||\n    isNewComponentStackFormat ||\n    isNewJSCComponentStackFormat\n  );\n}\n\nexport function parseComponentStack(message: string): {\n  type: ComponentStackType,\n  stack: ComponentStack,\n} {\n  // In newer versions of React, the component stack is formatted as a call stack frame.\n  // First try to parse the component stack as a call stack frame, and if that doesn't\n  // work then we'll fallback to the old custom component stack format parsing.\n  const stack = parseErrorStack(message);\n  if (stack && stack.length > 0) {\n    return {\n      type: 'stack',\n      stack: stack.map(frame => ({\n        content: frame.methodName,\n        collapse: frame.collapse || false,\n        fileName: frame.file == null ? 'unknown' : frame.file,\n        location: {\n          column: frame.column == null ? -1 : frame.column,\n          row: frame.lineNumber == null ? -1 : frame.lineNumber,\n        },\n      })),\n    };\n  }\n  const legacyStack = message\n    .split(RE_COMPONENT_STACK_LINE_GLOBAL)\n    .map(s => {\n      if (!s) {\n        return null;\n      }\n      const match = s.match(RE_COMPONENT_STACK_WITH_SOURCE);\n      if (match) {\n        let [content, fileName, row] = match.slice(1);\n        return {\n          content,\n          fileName,\n          location: {column: -1, row: parseInt(row, 10)},\n        };\n      }\n\n      // In some cases, the component stack doesn't have a source.\n      const matchWithoutSource = s.match(RE_COMPONENT_STACK_NO_SOURCE);\n      if (matchWithoutSource) {\n        return {\n          content: matchWithoutSource[1],\n          fileName: '',\n          location: null,\n        };\n      }\n\n      return null;\n    })\n    .filter(Boolean);\n\n  return {\n    type: 'legacy',\n    stack: legacyStack,\n  };\n}\n\nexport function parseLogBoxException(\n  error: ExtendedExceptionData,\n): LogBoxLogData {\n  const message =\n    error.originalMessage != null ? error.originalMessage : 'Unknown';\n\n  const metroInternalError = message.match(RE_METRO_ERROR_FORMAT);\n  if (metroInternalError) {\n    const [content, fileName, row, column, codeFrame] =\n      metroInternalError.slice(1);\n\n    return {\n      level: 'fatal',\n      type: 'Metro Error',\n      stack: [],\n      isComponentError: false,\n      componentStackType: 'legacy',\n      componentStack: [],\n      codeFrame: {\n        fileName,\n        location: {\n          row: parseInt(row, 10),\n          column: parseInt(column, 10),\n        },\n        content: codeFrame,\n      },\n      message: {\n        content,\n        substitutions: [],\n      },\n      category: `${fileName}-${row}-${column}`,\n      extraData: error.extraData,\n    };\n  }\n\n  const babelTransformError = message.match(RE_BABEL_TRANSFORM_ERROR_FORMAT);\n  if (babelTransformError) {\n    // Transform errors are thrown from inside the Babel transformer.\n    const [fileName, content, row, column, codeFrame] =\n      babelTransformError.slice(1);\n\n    return {\n      level: 'syntax',\n      stack: [],\n      isComponentError: false,\n      componentStackType: 'legacy',\n      componentStack: [],\n      codeFrame: {\n        fileName,\n        location: {\n          row: parseInt(row, 10),\n          column: parseInt(column, 10),\n        },\n        content: codeFrame,\n      },\n      message: {\n        content,\n        substitutions: [],\n      },\n      category: `${fileName}-${row}-${column}`,\n      extraData: error.extraData,\n    };\n  }\n\n  // Perform a cheap match first before trying to parse the full message, which\n  // can get expensive for arbitrary input.\n  if (RE_BABEL_CODE_FRAME_MARKER_PATTERN.test(message)) {\n    const babelCodeFrameError = message.match(RE_BABEL_CODE_FRAME_ERROR_FORMAT);\n\n    if (babelCodeFrameError) {\n      // Codeframe errors are thrown from any use of buildCodeFrameError.\n      const [fileName, content, codeFrame] = babelCodeFrameError.slice(1);\n      return {\n        level: 'syntax',\n        stack: [],\n        isComponentError: false,\n        componentStackType: 'legacy',\n        componentStack: [],\n        codeFrame: {\n          fileName,\n          location: null, // We are not given the location.\n          content: codeFrame,\n        },\n        message: {\n          content,\n          substitutions: [],\n        },\n        category: `${fileName}-${1}-${1}`,\n        extraData: error.extraData,\n      };\n    }\n  }\n\n  if (message.match(RE_TRANSFORM_ERROR)) {\n    return {\n      level: 'syntax',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStackType: 'legacy',\n      componentStack: [],\n      message: {\n        content: message,\n        substitutions: [],\n      },\n      category: message,\n      extraData: error.extraData,\n    };\n  }\n\n  const componentStack = error.componentStack;\n  if (error.isFatal || error.isComponentError) {\n    if (componentStack != null) {\n      const {type, stack} = parseComponentStack(componentStack);\n      return {\n        level: 'fatal',\n        stack: error.stack,\n        isComponentError: error.isComponentError,\n        componentStackType: type,\n        componentStack: stack,\n        extraData: error.extraData,\n        ...parseInterpolation([message]),\n      };\n    } else {\n      return {\n        level: 'fatal',\n        stack: error.stack,\n        isComponentError: error.isComponentError,\n        componentStackType: 'legacy',\n        componentStack: [],\n        extraData: error.extraData,\n        ...parseInterpolation([message]),\n      };\n    }\n  }\n\n  if (componentStack != null) {\n    // It is possible that console errors have a componentStack.\n    const {type, stack} = parseComponentStack(componentStack);\n    return {\n      level: 'error',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStackType: type,\n      componentStack: stack,\n      extraData: error.extraData,\n      ...parseInterpolation([message]),\n    };\n  }\n\n  // Most `console.error` calls won't have a componentStack. We parse them like\n  // regular logs which have the component stack buried in the message.\n  return {\n    level: 'error',\n    stack: error.stack,\n    isComponentError: error.isComponentError,\n    extraData: error.extraData,\n    ...parseLogBoxLog([message]),\n  };\n}\n\nexport function withoutANSIColorStyles(message: mixed): mixed {\n  if (typeof message !== 'string') {\n    return message;\n  }\n\n  return message.replace(\n    // eslint-disable-next-line no-control-regex\n    /[\\u001b\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g,\n    '',\n  );\n}\n\nexport function parseLogBoxLog(args: $ReadOnlyArray<mixed>): {\n  componentStack: ComponentStack,\n  componentStackType: ComponentStackType,\n  category: Category,\n  message: Message,\n} {\n  const message = withoutANSIColorStyles(args[0]);\n  let argsWithoutComponentStack: Array<mixed> = [];\n  let componentStack: ComponentStack = [];\n  let componentStackType = 'legacy';\n\n  // Extract component stack from warnings like \"Some warning%s\".\n  if (\n    typeof message === 'string' &&\n    message.slice(-2) === '%s' &&\n    args.length > 0\n  ) {\n    const lastArg = args[args.length - 1];\n    if (typeof lastArg === 'string' && isComponentStack(lastArg)) {\n      argsWithoutComponentStack = args.slice(0, -1);\n      argsWithoutComponentStack[0] = message.slice(0, -2);\n      const {type, stack} = parseComponentStack(lastArg);\n      componentStack = stack;\n      componentStackType = type;\n    }\n  }\n\n  if (componentStack.length === 0 && argsWithoutComponentStack.length === 0) {\n    // Try finding the component stack elsewhere.\n    for (const arg of args) {\n      if (typeof arg === 'string' && isComponentStack(arg)) {\n        // Strip out any messages before the component stack.\n        let messageEndIndex = arg.search(RE_COMPONENT_STACK_LINE);\n        if (messageEndIndex < 0) {\n          // Handle JSC component stacks.\n          messageEndIndex = arg.search(/\\n/);\n        }\n        if (messageEndIndex > 0) {\n          argsWithoutComponentStack.push(arg.slice(0, messageEndIndex));\n        }\n\n        const {type, stack} = parseComponentStack(arg);\n        componentStack = stack;\n        componentStackType = type;\n      } else {\n        argsWithoutComponentStack.push(arg);\n      }\n    }\n  }\n\n  return {\n    ...parseInterpolation(argsWithoutComponentStack),\n    componentStack,\n    componentStackType,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}