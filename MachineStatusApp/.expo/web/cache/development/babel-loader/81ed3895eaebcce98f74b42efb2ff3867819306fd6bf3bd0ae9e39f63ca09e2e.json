{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createAnimatedPropsHook;\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _AnimatedEvent = require(\"../../../Libraries/Animated/AnimatedEvent\");\nvar _AnimatedNode = _interopRequireDefault(require(\"../../../Libraries/Animated/nodes/AnimatedNode\"));\nvar _AnimatedProps = _interopRequireDefault(require(\"../../../Libraries/Animated/nodes/AnimatedProps\"));\nvar _AnimatedValue = _interopRequireDefault(require(\"../../../Libraries/Animated/nodes/AnimatedValue\"));\nvar _ReactFabricPublicInstanceUtils = require(\"../../../Libraries/ReactNative/ReactFabricPublicInstance/ReactFabricPublicInstanceUtils\");\nvar _useRefEffect = _interopRequireDefault(require(\"../../../Libraries/Utilities/useRefEffect\"));\nvar ReactNativeFeatureFlags = _interopRequireWildcard(require(\"../featureflags/ReactNativeFeatureFlags\"));\nvar _createAnimatedPropsMemoHook = require(\"./createAnimatedPropsMemoHook\");\nvar _NativeAnimatedHelper = _interopRequireDefault(require(\"./NativeAnimatedHelper\"));\nvar _react = require(\"react\");\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) \"default\" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }\nfunction createAnimatedPropsHook(allowlist) {\n  var useAnimatedPropsMemo = (0, _createAnimatedPropsMemoHook.createAnimatedPropsMemoHook)(allowlist);\n  return function useAnimatedProps(props) {\n    var _useReducer = (0, _react.useReducer)(function (count) {\n        return count + 1;\n      }, 0),\n      _useReducer2 = (0, _slicedToArray2.default)(_useReducer, 2),\n      scheduleUpdate = _useReducer2[1];\n    var onUpdateRef = (0, _react.useRef)(null);\n    var timerRef = (0, _react.useRef)(null);\n    var node = useAnimatedPropsMemo(function () {\n      return new _AnimatedProps.default(props, function () {\n        return onUpdateRef.current == null ? void 0 : onUpdateRef.current();\n      }, allowlist);\n    }, props);\n    var useNativePropsInFabric = ReactNativeFeatureFlags.shouldUseSetNativePropsInFabric();\n    (0, _react.useEffect)(function () {\n      _NativeAnimatedHelper.default.API.flushQueue();\n      var drivenAnimationEndedListener = null;\n      if (node.__isNative) {\n        drivenAnimationEndedListener = _NativeAnimatedHelper.default.nativeEventEmitter.addListener('onUserDrivenAnimationEnded', function (data) {\n          node.update();\n        });\n      }\n      return function () {\n        var _drivenAnimationEnded;\n        (_drivenAnimationEnded = drivenAnimationEndedListener) == null || _drivenAnimationEnded.remove();\n      };\n    });\n    var useAnimatedPropsLifecycle = ReactNativeFeatureFlags.scheduleAnimatedCleanupInMicrotask() ? useAnimatedPropsLifecycleWithCleanupInMicrotask : useAnimatedPropsLifecycleWithPrevNodeRef;\n    useAnimatedPropsLifecycle(node);\n    var refEffect = (0, _react.useCallback)(function (instance) {\n      node.setNativeView(instance);\n      onUpdateRef.current = function () {\n        if (process.env.NODE_ENV === 'test') {\n          return scheduleUpdate();\n        }\n        var isFabricNode = isFabricInstance(instance);\n        if (node.__isNative) {\n          if (isFabricNode) {\n            scheduleUpdate();\n          }\n          return;\n        }\n        if (typeof instance !== 'object' || typeof (instance == null ? void 0 : instance.setNativeProps) !== 'function') {\n          return scheduleUpdate();\n        }\n        if (!isFabricNode) {\n          return instance.setNativeProps(node.__getAnimatedValue());\n        }\n        if (!useNativePropsInFabric) {\n          return scheduleUpdate();\n        }\n        instance.setNativeProps(node.__getAnimatedValue());\n        if (timerRef.current != null) {\n          clearTimeout(timerRef.current);\n        }\n        timerRef.current = setTimeout(function () {\n          timerRef.current = null;\n          scheduleUpdate();\n        }, 48);\n      };\n      var target = getEventTarget(instance);\n      var events = [];\n      var animatedValueListeners = [];\n      for (var propName in props) {\n        var propValue = props[propName];\n        if (propValue instanceof _AnimatedEvent.AnimatedEvent && propValue.__isNative) {\n          propValue.__attach(target, propName);\n          events.push([propName, propValue]);\n          addListenersToPropsValue(propValue, animatedValueListeners);\n        }\n      }\n      return function () {\n        onUpdateRef.current = null;\n        for (var _ref of events) {\n          var _ref2 = (0, _slicedToArray2.default)(_ref, 2);\n          var _propName = _ref2[0];\n          var _propValue = _ref2[1];\n          _propValue.__detach(target, _propName);\n        }\n        for (var _ref3 of animatedValueListeners) {\n          var _propValue2 = _ref3.propValue;\n          var listenerId = _ref3.listenerId;\n          _propValue2.removeListener(listenerId);\n        }\n      };\n    }, [node, useNativePropsInFabric, props]);\n    var callbackRef = (0, _useRefEffect.default)(refEffect);\n    return [reduceAnimatedProps(node, props), callbackRef];\n  };\n}\nfunction reduceAnimatedProps(node, props) {\n  return Object.assign({}, node.__getValueWithStaticProps(props), {\n    collapsable: false\n  });\n}\nfunction addListenersToPropsValue(propValue, accumulator) {\n  if (propValue instanceof _AnimatedValue.default) {\n    var listenerId = propValue.addListener(function () {});\n    accumulator.push({\n      propValue: propValue,\n      listenerId: listenerId\n    });\n  } else if (Array.isArray(propValue)) {\n    for (var prop of propValue) {\n      addListenersToPropsValue(prop, accumulator);\n    }\n  } else if (propValue instanceof Object) {\n    addAnimatedValuesListenersToProps(propValue, accumulator);\n  }\n}\nfunction addAnimatedValuesListenersToProps(props, accumulator) {\n  for (var propName in props) {\n    var propValue = props[propName];\n    addListenersToPropsValue(propValue, accumulator);\n  }\n}\nfunction useAnimatedPropsLifecycleWithPrevNodeRef(node) {\n  var prevNodeRef = (0, _react.useRef)(null);\n  var isUnmountingRef = (0, _react.useRef)(false);\n  (0, _react.useInsertionEffect)(function () {\n    isUnmountingRef.current = false;\n    return function () {\n      isUnmountingRef.current = true;\n    };\n  }, []);\n  (0, _react.useInsertionEffect)(function () {\n    node.__attach();\n    if (prevNodeRef.current != null) {\n      var prevNode = prevNodeRef.current;\n      prevNode.__restoreDefaultValues();\n      prevNode.__detach();\n      prevNodeRef.current = null;\n    }\n    return function () {\n      if (isUnmountingRef.current) {\n        node.__detach();\n      } else {\n        prevNodeRef.current = node;\n      }\n    };\n  }, [node]);\n}\nfunction useAnimatedPropsLifecycleWithCleanupInMicrotask(node) {\n  var isMounted = (0, _react.useRef)(false);\n  (0, _react.useInsertionEffect)(function () {\n    isMounted.current = true;\n    node.__attach();\n    return function () {\n      isMounted.current = false;\n      queueMicrotask(function () {\n        if (isMounted.current) {\n          node.__restoreDefaultValues();\n        }\n        node.__detach();\n      });\n    };\n  }, [node]);\n}\nfunction getEventTarget(instance) {\n  return typeof instance === 'object' && typeof (instance == null ? void 0 : instance.getScrollableNode) === 'function' ? instance.getScrollableNode() : instance;\n}\nfunction isFabricInstance(instance) {\n  var _instance$getScrollRe;\n  return (0, _ReactFabricPublicInstanceUtils.isPublicInstance)(instance) || (0, _ReactFabricPublicInstanceUtils.isPublicInstance)(instance == null || instance.getNativeScrollRef == null ? void 0 : instance.getNativeScrollRef()) || (0, _ReactFabricPublicInstanceUtils.isPublicInstance)(instance == null || instance.getScrollResponder == null || (_instance$getScrollRe = instance.getScrollResponder()) == null || _instance$getScrollRe.getNativeScrollRef == null ? void 0 : _instance$getScrollRe.getNativeScrollRef());\n}","map":{"version":3,"names":["_AnimatedEvent","require","_AnimatedNode","_interopRequireDefault","_AnimatedProps","_AnimatedValue","_ReactFabricPublicInstanceUtils","_useRefEffect","ReactNativeFeatureFlags","_interopRequireWildcard","_createAnimatedPropsMemoHook","_NativeAnimatedHelper","_react","e","t","WeakMap","r","n","__esModule","o","i","f","__proto__","default","has","get","set","_t","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","createAnimatedPropsHook","allowlist","useAnimatedPropsMemo","createAnimatedPropsMemoHook","useAnimatedProps","props","_useReducer","useReducer","count","_useReducer2","_slicedToArray2","scheduleUpdate","onUpdateRef","useRef","timerRef","node","AnimatedProps","current","useNativePropsInFabric","shouldUseSetNativePropsInFabric","useEffect","NativeAnimatedHelper","API","flushQueue","drivenAnimationEndedListener","__isNative","nativeEventEmitter","addListener","data","update","_drivenAnimationEnded","remove","useAnimatedPropsLifecycle","scheduleAnimatedCleanupInMicrotask","useAnimatedPropsLifecycleWithCleanupInMicrotask","useAnimatedPropsLifecycleWithPrevNodeRef","refEffect","useCallback","instance","setNativeView","process","env","NODE_ENV","isFabricNode","isFabricInstance","setNativeProps","__getAnimatedValue","clearTimeout","setTimeout","target","getEventTarget","events","animatedValueListeners","propName","propValue","AnimatedEvent","__attach","push","addListenersToPropsValue","_ref","_ref2","__detach","_ref3","listenerId","removeListener","callbackRef","useRefEffect","reduceAnimatedProps","assign","__getValueWithStaticProps","collapsable","accumulator","AnimatedValue","Array","isArray","prop","addAnimatedValuesListenersToProps","prevNodeRef","isUnmountingRef","useInsertionEffect","prevNode","__restoreDefaultValues","isMounted","queueMicrotask","getScrollableNode","_instance$getScrollRe","isFabricPublicInstance","getNativeScrollRef","getScrollResponder"],"sources":["/Users/ayoubsadour/Desktop/APPMOBILE/MachineStatusApp/node_modules/react-native/src/private/animated/createAnimatedPropsHook.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\nimport type {AnimatedPropsAllowlist} from '../../../Libraries/Animated/nodes/AnimatedProps';\nimport type {EventSubscription} from '../../../Libraries/EventEmitter/NativeEventEmitter';\n\nimport {AnimatedEvent} from '../../../Libraries/Animated/AnimatedEvent';\nimport AnimatedNode from '../../../Libraries/Animated/nodes/AnimatedNode';\nimport AnimatedProps from '../../../Libraries/Animated/nodes/AnimatedProps';\nimport AnimatedValue from '../../../Libraries/Animated/nodes/AnimatedValue';\nimport {isPublicInstance as isFabricPublicInstance} from '../../../Libraries/ReactNative/ReactFabricPublicInstance/ReactFabricPublicInstanceUtils';\nimport useRefEffect from '../../../Libraries/Utilities/useRefEffect';\nimport * as ReactNativeFeatureFlags from '../featureflags/ReactNativeFeatureFlags';\nimport {createAnimatedPropsMemoHook} from './createAnimatedPropsMemoHook';\nimport NativeAnimatedHelper from './NativeAnimatedHelper';\nimport {\n  useCallback,\n  useEffect,\n  useInsertionEffect,\n  useReducer,\n  useRef,\n} from 'react';\n\ntype ReducedProps<TProps> = {\n  ...TProps,\n  collapsable: boolean,\n  ...\n};\ntype CallbackRef<T> = T => mixed;\n\nexport type AnimatedPropsHook = <TProps: {...}, TInstance>(\n  props: TProps,\n) => [ReducedProps<TProps>, CallbackRef<TInstance | null>];\n\ntype UpdateCallback = () => void;\n\ntype AnimatedValueListeners = Array<{\n  propValue: AnimatedValue,\n  listenerId: string,\n}>;\n\nexport default function createAnimatedPropsHook(\n  allowlist: ?AnimatedPropsAllowlist,\n): AnimatedPropsHook {\n  const useAnimatedPropsMemo = createAnimatedPropsMemoHook(allowlist);\n\n  return function useAnimatedProps<TProps: {...}, TInstance>(\n    props: TProps,\n  ): [ReducedProps<TProps>, CallbackRef<TInstance | null>] {\n    const [, scheduleUpdate] = useReducer<number, void>(count => count + 1, 0);\n    const onUpdateRef = useRef<UpdateCallback | null>(null);\n    const timerRef = useRef<TimeoutID | null>(null);\n\n    const node = useAnimatedPropsMemo(\n      () => new AnimatedProps(props, () => onUpdateRef.current?.(), allowlist),\n      props,\n    );\n\n    const useNativePropsInFabric =\n      ReactNativeFeatureFlags.shouldUseSetNativePropsInFabric();\n\n    useEffect(() => {\n      // If multiple components call `flushQueue`, the first one will flush the\n      // queue and subsequent ones will do nothing.\n      NativeAnimatedHelper.API.flushQueue();\n      let drivenAnimationEndedListener: ?EventSubscription = null;\n      if (node.__isNative) {\n        drivenAnimationEndedListener =\n          NativeAnimatedHelper.nativeEventEmitter.addListener(\n            'onUserDrivenAnimationEnded',\n            data => {\n              node.update();\n            },\n          );\n      }\n\n      return () => {\n        drivenAnimationEndedListener?.remove();\n      };\n    });\n\n    // NOTE: This feature flag must be evaluated inside the hook because this\n    // module factory can be evaluated much sooner, before overrides are set.\n    const useAnimatedPropsLifecycle =\n      ReactNativeFeatureFlags.scheduleAnimatedCleanupInMicrotask()\n        ? useAnimatedPropsLifecycleWithCleanupInMicrotask\n        : useAnimatedPropsLifecycleWithPrevNodeRef;\n\n    useAnimatedPropsLifecycle(node);\n\n    // TODO: This \"effect\" does three things:\n    //\n    //   1) Call `setNativeView`.\n    //   2) Update `onUpdateRef`.\n    //   3) Update listeners for `AnimatedEvent` props.\n    //\n    // Ideally, each of these would be separate \"effects\" so that they are not\n    // unnecessarily re-run when irrelevant dependencies change. For example, we\n    // should be able to hoist all `AnimatedEvent` props and only do #3 if either\n    // the `AnimatedEvent` props change or `instance` changes.\n    //\n    // But there is no way to transparently compose three separate callback refs,\n    // so we just combine them all into one for now.\n    const refEffect = useCallback(\n      (instance: TInstance) => {\n        // NOTE: This may be called more often than necessary (e.g. when `props`\n        // changes), but `setNativeView` already optimizes for that.\n        node.setNativeView(instance);\n\n        // NOTE: When using the JS animation driver, this callback is called on\n        // every animation frame. When using the native driver, this callback is\n        // called when the animation completes.\n        onUpdateRef.current = () => {\n          if (process.env.NODE_ENV === 'test') {\n            // Check 1: this is a test.\n            // call `scheduleUpdate` to bypass use of setNativeProps.\n            return scheduleUpdate();\n          }\n\n          const isFabricNode = isFabricInstance(instance);\n          if (node.__isNative) {\n            // Check 2: this is an animation driven by native.\n            // In native driven animations, this callback is only called once the animation completes.\n            if (isFabricNode) {\n              // Call `scheduleUpdate` to synchronise Fiber and Shadow tree.\n              // Must not be called in Paper.\n              scheduleUpdate();\n            }\n            return;\n          }\n\n          if (\n            typeof instance !== 'object' ||\n            typeof instance?.setNativeProps !== 'function'\n          ) {\n            // Check 3: the instance does not support setNativeProps. Call `scheduleUpdate`.\n            return scheduleUpdate();\n          }\n\n          if (!isFabricNode) {\n            // Check 4: this is a paper instance, call setNativeProps.\n            // $FlowIgnore[not-a-function] - Assume it's still a function.\n            // $FlowFixMe[incompatible-use]\n            return instance.setNativeProps(node.__getAnimatedValue());\n          }\n\n          if (!useNativePropsInFabric) {\n            // Check 5: setNativeProps are disabled.\n            return scheduleUpdate();\n          }\n\n          // This is a Fabric instance and setNativeProps is supported.\n\n          // $FlowIgnore[not-a-function] - Assume it's still a function.\n          // $FlowFixMe[incompatible-use]\n          instance.setNativeProps(node.__getAnimatedValue());\n\n          // Keeping state of Fiber tree and Shadow tree in sync.\n          //\n          // This is done by calling `scheduleUpdate` which will trigger a commit.\n          // However, React commit is not fast enough to drive animations.\n          // This is where setNativeProps comes in handy but the state between\n          // Fiber tree and Shadow tree needs to be kept in sync.\n          // The goal is to call `scheduleUpdate` as little as possible to maintain\n          // performance but frequently enough to keep state in sync.\n          // Debounce is set to 48ms, which is 3 * the duration of a frame.\n          // 3 frames was the highest value where flickering state was not observed.\n          if (timerRef.current != null) {\n            clearTimeout(timerRef.current);\n          }\n          timerRef.current = setTimeout(() => {\n            timerRef.current = null;\n            scheduleUpdate();\n          }, 48);\n        };\n\n        const target = getEventTarget(instance);\n        const events = [];\n        const animatedValueListeners: AnimatedValueListeners = [];\n\n        for (const propName in props) {\n          // $FlowFixMe[invalid-computed-prop]\n          const propValue = props[propName];\n          if (propValue instanceof AnimatedEvent && propValue.__isNative) {\n            propValue.__attach(target, propName);\n            events.push([propName, propValue]);\n            // $FlowFixMe[incompatible-call] - the `addListenersToPropsValue` drills down the propValue.\n            addListenersToPropsValue(propValue, animatedValueListeners);\n          }\n        }\n\n        return () => {\n          onUpdateRef.current = null;\n\n          for (const [propName, propValue] of events) {\n            propValue.__detach(target, propName);\n          }\n\n          for (const {propValue, listenerId} of animatedValueListeners) {\n            propValue.removeListener(listenerId);\n          }\n        };\n      },\n      [node, useNativePropsInFabric, props],\n    );\n    const callbackRef = useRefEffect<TInstance>(refEffect);\n\n    return [reduceAnimatedProps<TProps>(node, props), callbackRef];\n  };\n}\n\nfunction reduceAnimatedProps<TProps>(\n  node: AnimatedProps,\n  props: TProps,\n): ReducedProps<TProps> {\n  // Force `collapsable` to be false so that the native view is not flattened.\n  // Flattened views cannot be accurately referenced by the native driver.\n  return {\n    ...node.__getValueWithStaticProps(props),\n    collapsable: false,\n  };\n}\n\nfunction addListenersToPropsValue(\n  propValue: AnimatedValue,\n  accumulator: AnimatedValueListeners,\n) {\n  // propValue can be a scalar value, an array or an object.\n  if (propValue instanceof AnimatedValue) {\n    const listenerId = propValue.addListener(() => {});\n    accumulator.push({propValue, listenerId});\n  } else if (Array.isArray(propValue)) {\n    // An array can be an array of scalar values, arrays of arrays, or arrays of objects\n    for (const prop of propValue) {\n      addListenersToPropsValue(prop, accumulator);\n    }\n  } else if (propValue instanceof Object) {\n    addAnimatedValuesListenersToProps(propValue, accumulator);\n  }\n}\n\nfunction addAnimatedValuesListenersToProps(\n  props: AnimatedNode,\n  accumulator: AnimatedValueListeners,\n) {\n  for (const propName in props) {\n    // $FlowFixMe[prop-missing] - This is an object contained in a prop, but we don't know the exact type.\n    const propValue = props[propName];\n    addListenersToPropsValue(propValue, accumulator);\n  }\n}\n\n/**\n * Manages the lifecycle of the supplied `AnimatedProps` by invoking `__attach`\n * and `__detach`. However, this is more complicated because `AnimatedProps`\n * uses reference counting to determine when to recursively detach its children\n * nodes. So in order to optimize this, we avoid detaching until the next attach\n * unless we are unmounting.\n */\nfunction useAnimatedPropsLifecycleWithPrevNodeRef(node: AnimatedProps): void {\n  const prevNodeRef = useRef<?AnimatedProps>(null);\n  const isUnmountingRef = useRef<boolean>(false);\n\n  useInsertionEffect(() => {\n    isUnmountingRef.current = false;\n    return () => {\n      isUnmountingRef.current = true;\n    };\n  }, []);\n\n  useInsertionEffect(() => {\n    node.__attach();\n    if (prevNodeRef.current != null) {\n      const prevNode = prevNodeRef.current;\n      // TODO: Stop restoring default values (unless `reset` is called).\n      prevNode.__restoreDefaultValues();\n      prevNode.__detach();\n      prevNodeRef.current = null;\n    }\n    return () => {\n      if (isUnmountingRef.current) {\n        // NOTE: Do not restore default values on unmount, see D18197735.\n        node.__detach();\n      } else {\n        prevNodeRef.current = node;\n      }\n    };\n  }, [node]);\n}\n\n/**\n * Manages the lifecycle of the supplied `AnimatedProps` by invoking `__attach`\n * and `__detach`. However, `__detach` occurs in a microtask for these reasons:\n *\n *   1. Optimizes detaching and attaching `AnimatedNode` instances that rely on\n *      reference counting to cleanup state, by causing detach to be scheduled\n *      after any subsequent attach.\n *   2. Avoids calling `detach` during the insertion effect phase (which\n *      occurs during the commit phase), which may invoke completion callbacks.\n *\n * We should avoid invoking completion callbacks during the commit phase because\n * callbacks may update state, which is unsupported and will force synchronous\n * updates.\n */\nfunction useAnimatedPropsLifecycleWithCleanupInMicrotask(\n  node: AnimatedProps,\n): void {\n  const isMounted = useRef<boolean>(false);\n\n  useInsertionEffect(() => {\n    isMounted.current = true;\n    node.__attach();\n\n    return () => {\n      isMounted.current = false;\n      queueMicrotask(() => {\n        // NOTE: Do not restore default values on unmount, see D18197735.\n        if (isMounted.current) {\n          // TODO: Stop restoring default values (unless `reset` is called).\n          node.__restoreDefaultValues();\n        }\n        node.__detach();\n      });\n    };\n  }, [node]);\n}\n\nfunction getEventTarget<TInstance>(instance: TInstance): TInstance {\n  return typeof instance === 'object' &&\n    typeof instance?.getScrollableNode === 'function'\n    ? // $FlowFixMe[incompatible-use] - Legacy instance assumptions.\n      instance.getScrollableNode()\n    : instance;\n}\n\n// $FlowFixMe[unclear-type] - Legacy instance assumptions.\nfunction isFabricInstance(instance: any): boolean {\n  return (\n    isFabricPublicInstance(instance) ||\n    // Some components have a setNativeProps function but aren't a host component\n    // such as lists like FlatList and SectionList. These should also use\n    // forceUpdate in Fabric since setNativeProps doesn't exist on the underlying\n    // host component. This crazy hack is essentially special casing those lists and\n    // ScrollView itself to use forceUpdate in Fabric.\n    // If these components end up using forwardRef then these hacks can go away\n    // as instance would actually be the underlying host component and the above check\n    // would be sufficient.\n    isFabricPublicInstance(instance?.getNativeScrollRef?.()) ||\n    isFabricPublicInstance(\n      instance?.getScrollResponder?.()?.getNativeScrollRef?.(),\n    )\n  );\n}\n"],"mappings":";;;;;;AAaA,IAAAA,cAAA,GAAAC,OAAA;AACA,IAAAC,aAAA,GAAAC,sBAAA,CAAAF,OAAA;AACA,IAAAG,cAAA,GAAAD,sBAAA,CAAAF,OAAA;AACA,IAAAI,cAAA,GAAAF,sBAAA,CAAAF,OAAA;AACA,IAAAK,+BAAA,GAAAL,OAAA;AACA,IAAAM,aAAA,GAAAJ,sBAAA,CAAAF,OAAA;AACA,IAAAO,uBAAA,GAAAC,uBAAA,CAAAR,OAAA;AACA,IAAAS,4BAAA,GAAAT,OAAA;AACA,IAAAU,qBAAA,GAAAR,sBAAA,CAAAF,OAAA;AACA,IAAAW,MAAA,GAAAX,OAAA;AAMe,SAAAQ,wBAAAI,CAAA,EAAAC,CAAA,6BAAAC,OAAA,MAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAN,uBAAA,YAAAA,wBAAAI,CAAA,EAAAC,CAAA,SAAAA,CAAA,IAAAD,CAAA,IAAAA,CAAA,CAAAK,UAAA,SAAAL,CAAA,MAAAM,CAAA,EAAAC,CAAA,EAAAC,CAAA,KAAAC,SAAA,QAAAC,OAAA,EAAAV,CAAA,iBAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,SAAAQ,CAAA,MAAAF,CAAA,GAAAL,CAAA,GAAAG,CAAA,GAAAD,CAAA,QAAAG,CAAA,CAAAK,GAAA,CAAAX,CAAA,UAAAM,CAAA,CAAAM,GAAA,CAAAZ,CAAA,GAAAM,CAAA,CAAAO,GAAA,CAAAb,CAAA,EAAAQ,CAAA,cAAAM,EAAA,IAAAd,CAAA,gBAAAc,EAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,EAAA,OAAAP,CAAA,IAAAD,CAAA,GAAAW,MAAA,CAAAC,cAAA,KAAAD,MAAA,CAAAE,wBAAA,CAAAnB,CAAA,EAAAc,EAAA,OAAAP,CAAA,CAAAK,GAAA,IAAAL,CAAA,CAAAM,GAAA,IAAAP,CAAA,CAAAE,CAAA,EAAAM,EAAA,EAAAP,CAAA,IAAAC,CAAA,CAAAM,EAAA,IAAAd,CAAA,CAAAc,EAAA,WAAAN,CAAA,KAAAR,CAAA,EAAAC,CAAA;AAoBA,SAASmB,uBAAuBA,CAC7CC,SAAkC,EACf;EACnB,IAAMC,oBAAoB,GAAG,IAAAC,wDAA2B,EAACF,SAAS,CAAC;EAEnE,OAAO,SAASG,gBAAgBA,CAC9BC,KAAa,EAC0C;IACvD,IAAAC,WAAA,GAA2B,IAAAC,iBAAU,EAAe,UAAAC,KAAK;QAAA,OAAIA,KAAK,GAAG,CAAC;MAAA,GAAE,CAAC,CAAC;MAAAC,YAAA,OAAAC,eAAA,CAAApB,OAAA,EAAAgB,WAAA;MAAjEK,cAAc,GAAAF,YAAA;IACvB,IAAMG,WAAW,GAAG,IAAAC,aAAM,EAAwB,IAAI,CAAC;IACvD,IAAMC,QAAQ,GAAG,IAAAD,aAAM,EAAmB,IAAI,CAAC;IAE/C,IAAME,IAAI,GAAGb,oBAAoB,CAC/B;MAAA,OAAM,IAAIc,sBAAa,CAACX,KAAK,EAAE;QAAA,OAAMO,WAAW,CAACK,OAAO,oBAAnBL,WAAW,CAACK,OAAO,CAAG,CAAC;MAAA,GAAEhB,SAAS,CAAC;IAAA,GACxEI,KACF,CAAC;IAED,IAAMa,sBAAsB,GAC1B3C,uBAAuB,CAAC4C,+BAA+B,CAAC,CAAC;IAE3D,IAAAC,gBAAS,EAAC,YAAM;MAGdC,6BAAoB,CAACC,GAAG,CAACC,UAAU,CAAC,CAAC;MACrC,IAAIC,4BAAgD,GAAG,IAAI;MAC3D,IAAIT,IAAI,CAACU,UAAU,EAAE;QACnBD,4BAA4B,GAC1BH,6BAAoB,CAACK,kBAAkB,CAACC,WAAW,CACjD,4BAA4B,EAC5B,UAAAC,IAAI,EAAI;UACNb,IAAI,CAACc,MAAM,CAAC,CAAC;QACf,CACF,CAAC;MACL;MAEA,OAAO,YAAM;QAAA,IAAAC,qBAAA;QACX,CAAAA,qBAAA,GAAAN,4BAA4B,aAA5BM,qBAAA,CAA8BC,MAAM,CAAC,CAAC;MACxC,CAAC;IACH,CAAC,CAAC;IAIF,IAAMC,yBAAyB,GAC7BzD,uBAAuB,CAAC0D,kCAAkC,CAAC,CAAC,GACxDC,+CAA+C,GAC/CC,wCAAwC;IAE9CH,yBAAyB,CAACjB,IAAI,CAAC;IAe/B,IAAMqB,SAAS,GAAG,IAAAC,kBAAW,EAC3B,UAACC,QAAmB,EAAK;MAGvBvB,IAAI,CAACwB,aAAa,CAACD,QAAQ,CAAC;MAK5B1B,WAAW,CAACK,OAAO,GAAG,YAAM;QAC1B,IAAIuB,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,MAAM,EAAE;UAGnC,OAAO/B,cAAc,CAAC,CAAC;QACzB;QAEA,IAAMgC,YAAY,GAAGC,gBAAgB,CAACN,QAAQ,CAAC;QAC/C,IAAIvB,IAAI,CAACU,UAAU,EAAE;UAGnB,IAAIkB,YAAY,EAAE;YAGhBhC,cAAc,CAAC,CAAC;UAClB;UACA;QACF;QAEA,IACE,OAAO2B,QAAQ,KAAK,QAAQ,IAC5B,QAAOA,QAAQ,oBAARA,QAAQ,CAAEO,cAAc,MAAK,UAAU,EAC9C;UAEA,OAAOlC,cAAc,CAAC,CAAC;QACzB;QAEA,IAAI,CAACgC,YAAY,EAAE;UAIjB,OAAOL,QAAQ,CAACO,cAAc,CAAC9B,IAAI,CAAC+B,kBAAkB,CAAC,CAAC,CAAC;QAC3D;QAEA,IAAI,CAAC5B,sBAAsB,EAAE;UAE3B,OAAOP,cAAc,CAAC,CAAC;QACzB;QAMA2B,QAAQ,CAACO,cAAc,CAAC9B,IAAI,CAAC+B,kBAAkB,CAAC,CAAC,CAAC;QAYlD,IAAIhC,QAAQ,CAACG,OAAO,IAAI,IAAI,EAAE;UAC5B8B,YAAY,CAACjC,QAAQ,CAACG,OAAO,CAAC;QAChC;QACAH,QAAQ,CAACG,OAAO,GAAG+B,UAAU,CAAC,YAAM;UAClClC,QAAQ,CAACG,OAAO,GAAG,IAAI;UACvBN,cAAc,CAAC,CAAC;QAClB,CAAC,EAAE,EAAE,CAAC;MACR,CAAC;MAED,IAAMsC,MAAM,GAAGC,cAAc,CAACZ,QAAQ,CAAC;MACvC,IAAMa,MAAM,GAAG,EAAE;MACjB,IAAMC,sBAA8C,GAAG,EAAE;MAEzD,KAAK,IAAMC,QAAQ,IAAIhD,KAAK,EAAE;QAE5B,IAAMiD,SAAS,GAAGjD,KAAK,CAACgD,QAAQ,CAAC;QACjC,IAAIC,SAAS,YAAYC,4BAAa,IAAID,SAAS,CAAC7B,UAAU,EAAE;UAC9D6B,SAAS,CAACE,QAAQ,CAACP,MAAM,EAAEI,QAAQ,CAAC;UACpCF,MAAM,CAACM,IAAI,CAAC,CAACJ,QAAQ,EAAEC,SAAS,CAAC,CAAC;UAElCI,wBAAwB,CAACJ,SAAS,EAAEF,sBAAsB,CAAC;QAC7D;MACF;MAEA,OAAO,YAAM;QACXxC,WAAW,CAACK,OAAO,GAAG,IAAI;QAE1B,SAAA0C,IAAA,IAAoCR,MAAM,EAAE;UAAA,IAAAS,KAAA,OAAAlD,eAAA,CAAApB,OAAA,EAAAqE,IAAA;UAAA,IAAhCN,SAAQ,GAAAO,KAAA;UAAA,IAAEN,UAAS,GAAAM,KAAA;UAC7BN,UAAS,CAACO,QAAQ,CAACZ,MAAM,EAAEI,SAAQ,CAAC;QACtC;QAEA,SAAAS,KAAA,IAAsCV,sBAAsB,EAAE;UAAA,IAAlDE,WAAS,GAAAQ,KAAA,CAATR,SAAS;UAAA,IAAES,UAAU,GAAAD,KAAA,CAAVC,UAAU;UAC/BT,WAAS,CAACU,cAAc,CAACD,UAAU,CAAC;QACtC;MACF,CAAC;IACH,CAAC,EACD,CAAChD,IAAI,EAAEG,sBAAsB,EAAEb,KAAK,CACtC,CAAC;IACD,IAAM4D,WAAW,GAAG,IAAAC,qBAAY,EAAY9B,SAAS,CAAC;IAEtD,OAAO,CAAC+B,mBAAmB,CAASpD,IAAI,EAAEV,KAAK,CAAC,EAAE4D,WAAW,CAAC;EAChE,CAAC;AACH;AAEA,SAASE,mBAAmBA,CAC1BpD,IAAmB,EACnBV,KAAa,EACS;EAGtB,OAAAR,MAAA,CAAAuE,MAAA,KACKrD,IAAI,CAACsD,yBAAyB,CAAChE,KAAK,CAAC;IACxCiE,WAAW,EAAE;EAAK;AAEtB;AAEA,SAASZ,wBAAwBA,CAC/BJ,SAAwB,EACxBiB,WAAmC,EACnC;EAEA,IAAIjB,SAAS,YAAYkB,sBAAa,EAAE;IACtC,IAAMT,UAAU,GAAGT,SAAS,CAAC3B,WAAW,CAAC,YAAM,CAAC,CAAC,CAAC;IAClD4C,WAAW,CAACd,IAAI,CAAC;MAACH,SAAS,EAATA,SAAS;MAAES,UAAU,EAAVA;IAAU,CAAC,CAAC;EAC3C,CAAC,MAAM,IAAIU,KAAK,CAACC,OAAO,CAACpB,SAAS,CAAC,EAAE;IAEnC,KAAK,IAAMqB,IAAI,IAAIrB,SAAS,EAAE;MAC5BI,wBAAwB,CAACiB,IAAI,EAAEJ,WAAW,CAAC;IAC7C;EACF,CAAC,MAAM,IAAIjB,SAAS,YAAYzD,MAAM,EAAE;IACtC+E,iCAAiC,CAACtB,SAAS,EAAEiB,WAAW,CAAC;EAC3D;AACF;AAEA,SAASK,iCAAiCA,CACxCvE,KAAmB,EACnBkE,WAAmC,EACnC;EACA,KAAK,IAAMlB,QAAQ,IAAIhD,KAAK,EAAE;IAE5B,IAAMiD,SAAS,GAAGjD,KAAK,CAACgD,QAAQ,CAAC;IACjCK,wBAAwB,CAACJ,SAAS,EAAEiB,WAAW,CAAC;EAClD;AACF;AASA,SAASpC,wCAAwCA,CAACpB,IAAmB,EAAQ;EAC3E,IAAM8D,WAAW,GAAG,IAAAhE,aAAM,EAAiB,IAAI,CAAC;EAChD,IAAMiE,eAAe,GAAG,IAAAjE,aAAM,EAAU,KAAK,CAAC;EAE9C,IAAAkE,yBAAkB,EAAC,YAAM;IACvBD,eAAe,CAAC7D,OAAO,GAAG,KAAK;IAC/B,OAAO,YAAM;MACX6D,eAAe,CAAC7D,OAAO,GAAG,IAAI;IAChC,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;EAEN,IAAA8D,yBAAkB,EAAC,YAAM;IACvBhE,IAAI,CAACyC,QAAQ,CAAC,CAAC;IACf,IAAIqB,WAAW,CAAC5D,OAAO,IAAI,IAAI,EAAE;MAC/B,IAAM+D,QAAQ,GAAGH,WAAW,CAAC5D,OAAO;MAEpC+D,QAAQ,CAACC,sBAAsB,CAAC,CAAC;MACjCD,QAAQ,CAACnB,QAAQ,CAAC,CAAC;MACnBgB,WAAW,CAAC5D,OAAO,GAAG,IAAI;IAC5B;IACA,OAAO,YAAM;MACX,IAAI6D,eAAe,CAAC7D,OAAO,EAAE;QAE3BF,IAAI,CAAC8C,QAAQ,CAAC,CAAC;MACjB,CAAC,MAAM;QACLgB,WAAW,CAAC5D,OAAO,GAAGF,IAAI;MAC5B;IACF,CAAC;EACH,CAAC,EAAE,CAACA,IAAI,CAAC,CAAC;AACZ;AAgBA,SAASmB,+CAA+CA,CACtDnB,IAAmB,EACb;EACN,IAAMmE,SAAS,GAAG,IAAArE,aAAM,EAAU,KAAK,CAAC;EAExC,IAAAkE,yBAAkB,EAAC,YAAM;IACvBG,SAAS,CAACjE,OAAO,GAAG,IAAI;IACxBF,IAAI,CAACyC,QAAQ,CAAC,CAAC;IAEf,OAAO,YAAM;MACX0B,SAAS,CAACjE,OAAO,GAAG,KAAK;MACzBkE,cAAc,CAAC,YAAM;QAEnB,IAAID,SAAS,CAACjE,OAAO,EAAE;UAErBF,IAAI,CAACkE,sBAAsB,CAAC,CAAC;QAC/B;QACAlE,IAAI,CAAC8C,QAAQ,CAAC,CAAC;MACjB,CAAC,CAAC;IACJ,CAAC;EACH,CAAC,EAAE,CAAC9C,IAAI,CAAC,CAAC;AACZ;AAEA,SAASmC,cAAcA,CAAYZ,QAAmB,EAAa;EACjE,OAAO,OAAOA,QAAQ,KAAK,QAAQ,IACjC,QAAOA,QAAQ,oBAARA,QAAQ,CAAE8C,iBAAiB,MAAK,UAAU,GAE/C9C,QAAQ,CAAC8C,iBAAiB,CAAC,CAAC,GAC5B9C,QAAQ;AACd;AAGA,SAASM,gBAAgBA,CAACN,QAAa,EAAW;EAAA,IAAA+C,qBAAA;EAChD,OACE,IAAAC,gDAAsB,EAAChD,QAAQ,CAAC,IAShC,IAAAgD,gDAAsB,EAAChD,QAAQ,YAARA,QAAQ,CAAEiD,kBAAkB,oBAA5BjD,QAAQ,CAAEiD,kBAAkB,CAAG,CAAC,CAAC,IACxD,IAAAD,gDAAsB,EACpBhD,QAAQ,YAARA,QAAQ,CAAEkD,kBAAkB,aAAAH,qBAAA,GAA5B/C,QAAQ,CAAEkD,kBAAkB,CAAG,CAAC,aAAhCH,qBAAA,CAAkCE,kBAAkB,oBAApDF,qBAAA,CAAkCE,kBAAkB,CAAG,CACzD,CAAC;AAEL","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}