{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _VirtualizeUtils = require(\"./VirtualizeUtils\");\nvar _invariant = _interopRequireDefault(require(\"invariant\"));\nvar ListMetricsAggregator = exports.default = function () {\n  function ListMetricsAggregator() {\n    (0, _classCallCheck2.default)(this, ListMetricsAggregator);\n    this._averageCellLength = 0;\n    this._cellMetrics = new Map();\n    this._highestMeasuredCellIndex = 0;\n    this._measuredCellsLength = 0;\n    this._measuredCellsCount = 0;\n    this._orientation = {\n      horizontal: false,\n      rtl: false\n    };\n  }\n  return (0, _createClass2.default)(ListMetricsAggregator, [{\n    key: \"notifyCellLayout\",\n    value: function notifyCellLayout(_ref) {\n      var cellIndex = _ref.cellIndex,\n        cellKey = _ref.cellKey,\n        orientation = _ref.orientation,\n        layout = _ref.layout;\n      this._invalidateIfOrientationChanged(orientation);\n      var next = {\n        index: cellIndex,\n        length: this._selectLength(layout),\n        isMounted: true,\n        offset: this.flowRelativeOffset(layout)\n      };\n      var curr = this._cellMetrics.get(cellKey);\n      if (!curr || next.offset !== curr.offset || next.length !== curr.length) {\n        if (curr) {\n          var dLength = next.length - curr.length;\n          this._measuredCellsLength += dLength;\n        } else {\n          this._measuredCellsLength += next.length;\n          this._measuredCellsCount += 1;\n        }\n        this._averageCellLength = this._measuredCellsLength / this._measuredCellsCount;\n        this._cellMetrics.set(cellKey, next);\n        this._highestMeasuredCellIndex = Math.max(this._highestMeasuredCellIndex, cellIndex);\n        return true;\n      } else {\n        curr.isMounted = true;\n        return false;\n      }\n    }\n  }, {\n    key: \"notifyCellUnmounted\",\n    value: function notifyCellUnmounted(cellKey) {\n      var curr = this._cellMetrics.get(cellKey);\n      if (curr) {\n        curr.isMounted = false;\n      }\n    }\n  }, {\n    key: \"notifyListContentLayout\",\n    value: function notifyListContentLayout(_ref2) {\n      var orientation = _ref2.orientation,\n        layout = _ref2.layout;\n      this._invalidateIfOrientationChanged(orientation);\n      this._contentLength = this._selectLength(layout);\n    }\n  }, {\n    key: \"getAverageCellLength\",\n    value: function getAverageCellLength() {\n      return this._averageCellLength;\n    }\n  }, {\n    key: \"getHighestMeasuredCellIndex\",\n    value: function getHighestMeasuredCellIndex() {\n      return this._highestMeasuredCellIndex;\n    }\n  }, {\n    key: \"getCellMetricsApprox\",\n    value: function getCellMetricsApprox(index, props) {\n      var frame = this.getCellMetrics(index, props);\n      if (frame && frame.index === index) {\n        return frame;\n      } else {\n        var offset;\n        var highestMeasuredCellIndex = this.getHighestMeasuredCellIndex();\n        if (highestMeasuredCellIndex < index) {\n          var highestMeasuredCellFrame = this.getCellMetrics(highestMeasuredCellIndex, props);\n          if (highestMeasuredCellFrame) {\n            offset = highestMeasuredCellFrame.offset + highestMeasuredCellFrame.length + this._averageCellLength * (index - highestMeasuredCellIndex - 1);\n          }\n        }\n        if (offset == null) {\n          offset = this._averageCellLength * index;\n        }\n        var data = props.data,\n          getItemCount = props.getItemCount;\n        (0, _invariant.default)(index >= 0 && index < getItemCount(data), 'Tried to get frame for out of range index ' + index);\n        return {\n          length: this._averageCellLength,\n          offset: offset,\n          index: index,\n          isMounted: false\n        };\n      }\n    }\n  }, {\n    key: \"getCellMetrics\",\n    value: function getCellMetrics(index, props) {\n      var _props$keyExtractor;\n      var data = props.data,\n        getItem = props.getItem,\n        getItemCount = props.getItemCount,\n        getItemLayout = props.getItemLayout;\n      (0, _invariant.default)(index >= 0 && index < getItemCount(data), 'Tried to get metrics for out of range cell index ' + index);\n      var keyExtractor = (_props$keyExtractor = props.keyExtractor) != null ? _props$keyExtractor : _VirtualizeUtils.keyExtractor;\n      var frame = this._cellMetrics.get(keyExtractor(getItem(data, index), index));\n      if (frame && frame.index === index) {\n        return frame;\n      }\n      if (getItemLayout) {\n        var _getItemLayout = getItemLayout(data, index),\n          length = _getItemLayout.length,\n          offset = _getItemLayout.offset;\n        return {\n          index: index,\n          length: length,\n          offset: offset,\n          isMounted: true\n        };\n      }\n      return null;\n    }\n  }, {\n    key: \"getCellOffsetApprox\",\n    value: function getCellOffsetApprox(index, props) {\n      if (Number.isInteger(index)) {\n        return this.getCellMetricsApprox(index, props).offset;\n      } else {\n        var frameMetrics = this.getCellMetricsApprox(Math.floor(index), props);\n        var remainder = index - Math.floor(index);\n        return frameMetrics.offset + remainder * frameMetrics.length;\n      }\n    }\n  }, {\n    key: \"getContentLength\",\n    value: function getContentLength() {\n      var _this$_contentLength;\n      return (_this$_contentLength = this._contentLength) != null ? _this$_contentLength : 0;\n    }\n  }, {\n    key: \"hasContentLength\",\n    value: function hasContentLength() {\n      return this._contentLength != null;\n    }\n  }, {\n    key: \"flowRelativeOffset\",\n    value: function flowRelativeOffset(layout, referenceContentLength) {\n      var _this$_orientation = this._orientation,\n        horizontal = _this$_orientation.horizontal,\n        rtl = _this$_orientation.rtl;\n      if (horizontal && rtl) {\n        var contentLength = referenceContentLength != null ? referenceContentLength : this._contentLength;\n        (0, _invariant.default)(contentLength != null, 'ListMetricsAggregator must be notified of list content layout before resolving offsets');\n        return contentLength - (this._selectOffset(layout) + this._selectLength(layout));\n      } else {\n        return this._selectOffset(layout);\n      }\n    }\n  }, {\n    key: \"cartesianOffset\",\n    value: function cartesianOffset(flowRelativeOffset) {\n      var _this$_orientation2 = this._orientation,\n        horizontal = _this$_orientation2.horizontal,\n        rtl = _this$_orientation2.rtl;\n      if (horizontal && rtl) {\n        (0, _invariant.default)(this._contentLength != null, 'ListMetricsAggregator must be notified of list content layout before resolving offsets');\n        return this._contentLength - flowRelativeOffset;\n      } else {\n        return flowRelativeOffset;\n      }\n    }\n  }, {\n    key: \"_invalidateIfOrientationChanged\",\n    value: function _invalidateIfOrientationChanged(orientation) {\n      if (orientation.rtl !== this._orientation.rtl) {\n        this._cellMetrics.clear();\n      }\n      if (orientation.horizontal !== this._orientation.horizontal) {\n        this._averageCellLength = 0;\n        this._highestMeasuredCellIndex = 0;\n        this._measuredCellsLength = 0;\n        this._measuredCellsCount = 0;\n      }\n      this._orientation = orientation;\n    }\n  }, {\n    key: \"_selectLength\",\n    value: function _selectLength(_ref3) {\n      var width = _ref3.width,\n        height = _ref3.height;\n      return this._orientation.horizontal ? width : height;\n    }\n  }, {\n    key: \"_selectOffset\",\n    value: function _selectOffset(_ref4) {\n      var x = _ref4.x,\n        y = _ref4.y;\n      return this._orientation.horizontal ? x : y;\n    }\n  }]);\n}();","map":{"version":3,"names":["_VirtualizeUtils","require","_invariant","_interopRequireDefault","ListMetricsAggregator","exports","default","_classCallCheck2","_averageCellLength","_cellMetrics","Map","_highestMeasuredCellIndex","_measuredCellsLength","_measuredCellsCount","_orientation","horizontal","rtl","_createClass2","key","value","notifyCellLayout","_ref","cellIndex","cellKey","orientation","layout","_invalidateIfOrientationChanged","next","index","length","_selectLength","isMounted","offset","flowRelativeOffset","curr","get","dLength","set","Math","max","notifyCellUnmounted","notifyListContentLayout","_ref2","_contentLength","getAverageCellLength","getHighestMeasuredCellIndex","getCellMetricsApprox","props","frame","getCellMetrics","highestMeasuredCellIndex","highestMeasuredCellFrame","data","getItemCount","invariant","_props$keyExtractor","getItem","getItemLayout","keyExtractor","defaultKeyExtractor","_getItemLayout","getCellOffsetApprox","Number","isInteger","frameMetrics","floor","remainder","getContentLength","_this$_contentLength","hasContentLength","referenceContentLength","_this$_orientation","contentLength","_selectOffset","cartesianOffset","_this$_orientation2","clear","_ref3","width","height","_ref4","x","y"],"sources":["/Users/ayoubsadour/Desktop/APPMOBILE/MachineStatusApp/node_modules/@react-native/virtualized-lists/Lists/ListMetricsAggregator.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\nimport type {VirtualizedListProps} from './VirtualizedListProps';\nimport type {LayoutRectangle} from 'react-native/Libraries/Types/CoreEventTypes';\n\nimport {keyExtractor as defaultKeyExtractor} from './VirtualizeUtils';\nimport invariant from 'invariant';\n\nexport type CellMetrics = {\n  /**\n   * Index of the item in the list\n   */\n  index: number,\n  /**\n   * Length of the cell along the scrolling axis\n   */\n  length: number,\n  /**\n   * Distance between this cell and the start of the list along the scrolling\n   * axis\n   */\n  offset: number,\n  /**\n   * Whether the cell is last known to be mounted\n   */\n  isMounted: boolean,\n};\n\n// TODO: `inverted` can be incorporated here if it is moved to an order\n// based implementation instead of transform.\nexport type ListOrientation = {\n  horizontal: boolean,\n  rtl: boolean,\n};\n\n/**\n * Subset of VirtualizedList props needed to calculate cell metrics\n */\nexport type CellMetricProps = {\n  data: VirtualizedListProps['data'],\n  getItemCount: VirtualizedListProps['getItemCount'],\n  getItem: VirtualizedListProps['getItem'],\n  getItemLayout?: VirtualizedListProps['getItemLayout'],\n  keyExtractor?: VirtualizedListProps['keyExtractor'],\n  ...\n};\n\n/**\n * Provides an interface to query information about the metrics of a list and its cells.\n */\nexport default class ListMetricsAggregator {\n  _averageCellLength = 0;\n  _cellMetrics: Map<string, CellMetrics> = new Map();\n  _contentLength: ?number;\n  _highestMeasuredCellIndex = 0;\n  _measuredCellsLength = 0;\n  _measuredCellsCount = 0;\n  _orientation: ListOrientation = {\n    horizontal: false,\n    rtl: false,\n  };\n\n  /**\n   * Notify the ListMetricsAggregator that a cell has been laid out.\n   *\n   * @returns whether the cell layout has changed since last notification\n   */\n  notifyCellLayout({\n    cellIndex,\n    cellKey,\n    orientation,\n    layout,\n  }: {\n    cellIndex: number,\n    cellKey: string,\n    orientation: ListOrientation,\n    layout: LayoutRectangle,\n  }): boolean {\n    this._invalidateIfOrientationChanged(orientation);\n\n    const next: CellMetrics = {\n      index: cellIndex,\n      length: this._selectLength(layout),\n      isMounted: true,\n      offset: this.flowRelativeOffset(layout),\n    };\n    const curr = this._cellMetrics.get(cellKey);\n\n    if (!curr || next.offset !== curr.offset || next.length !== curr.length) {\n      if (curr) {\n        const dLength = next.length - curr.length;\n        this._measuredCellsLength += dLength;\n      } else {\n        this._measuredCellsLength += next.length;\n        this._measuredCellsCount += 1;\n      }\n\n      this._averageCellLength =\n        this._measuredCellsLength / this._measuredCellsCount;\n      this._cellMetrics.set(cellKey, next);\n      this._highestMeasuredCellIndex = Math.max(\n        this._highestMeasuredCellIndex,\n        cellIndex,\n      );\n      return true;\n    } else {\n      curr.isMounted = true;\n      return false;\n    }\n  }\n\n  /**\n   * Notify ListMetricsAggregator that a cell has been unmounted.\n   */\n  notifyCellUnmounted(cellKey: string): void {\n    const curr = this._cellMetrics.get(cellKey);\n    if (curr) {\n      curr.isMounted = false;\n    }\n  }\n\n  /**\n   * Notify ListMetricsAggregator that the lists content container has been laid out.\n   */\n  notifyListContentLayout({\n    orientation,\n    layout,\n  }: {\n    orientation: ListOrientation,\n    layout: $ReadOnly<{width: number, height: number}>,\n  }): void {\n    this._invalidateIfOrientationChanged(orientation);\n    this._contentLength = this._selectLength(layout);\n  }\n\n  /**\n   * Return the average length of the cells which have been measured\n   */\n  getAverageCellLength(): number {\n    return this._averageCellLength;\n  }\n\n  /**\n   * Return the highest measured cell index (or 0 if nothing has been measured\n   * yet)\n   */\n  getHighestMeasuredCellIndex(): number {\n    return this._highestMeasuredCellIndex;\n  }\n\n  /**\n   * Returns the exact metrics of a cell if it has already been laid out,\n   * otherwise an estimate based on the average length of previously measured\n   * cells\n   */\n  getCellMetricsApprox(index: number, props: CellMetricProps): CellMetrics {\n    const frame = this.getCellMetrics(index, props);\n    if (frame && frame.index === index) {\n      // check for invalid frames due to row re-ordering\n      return frame;\n    } else {\n      let offset;\n\n      const highestMeasuredCellIndex = this.getHighestMeasuredCellIndex();\n      if (highestMeasuredCellIndex < index) {\n        // If any of the cells before this one have been laid out already, we\n        // should use that information in the estimations.\n        // This is important because if the list has a header, the initial cell\n        // will have a larger offset that we should take into account here.\n        const highestMeasuredCellFrame = this.getCellMetrics(\n          highestMeasuredCellIndex,\n          props,\n        );\n        if (highestMeasuredCellFrame) {\n          offset =\n            highestMeasuredCellFrame.offset +\n            highestMeasuredCellFrame.length +\n            this._averageCellLength * (index - highestMeasuredCellIndex - 1);\n        }\n      }\n\n      if (offset == null) {\n        offset = this._averageCellLength * index;\n      }\n\n      const {data, getItemCount} = props;\n      invariant(\n        index >= 0 && index < getItemCount(data),\n        'Tried to get frame for out of range index ' + index,\n      );\n      return {\n        length: this._averageCellLength,\n        offset,\n        index,\n        isMounted: false,\n      };\n    }\n  }\n\n  /**\n   * Returns the exact metrics of a cell if it has already been laid out\n   */\n  getCellMetrics(index: number, props: CellMetricProps): ?CellMetrics {\n    const {data, getItem, getItemCount, getItemLayout} = props;\n    invariant(\n      index >= 0 && index < getItemCount(data),\n      'Tried to get metrics for out of range cell index ' + index,\n    );\n    const keyExtractor = props.keyExtractor ?? defaultKeyExtractor;\n    const frame = this._cellMetrics.get(\n      keyExtractor(getItem(data, index), index),\n    );\n    if (frame && frame.index === index) {\n      return frame;\n    }\n\n    if (getItemLayout) {\n      const {length, offset} = getItemLayout(data, index);\n      // TODO: `isMounted` is used for both \"is exact layout\" and \"has been\n      // unmounted\". Should be refactored.\n      return {index, length, offset, isMounted: true};\n    }\n\n    return null;\n  }\n\n  /**\n   * Gets an approximate offset to an item at a given index. Supports\n   * fractional indices.\n   */\n  getCellOffsetApprox(index: number, props: CellMetricProps): number {\n    if (Number.isInteger(index)) {\n      return this.getCellMetricsApprox(index, props).offset;\n    } else {\n      const frameMetrics = this.getCellMetricsApprox(Math.floor(index), props);\n      const remainder = index - Math.floor(index);\n      return frameMetrics.offset + remainder * frameMetrics.length;\n    }\n  }\n\n  /**\n   * Returns the length of all ScrollView content along the scrolling axis.\n   */\n  getContentLength(): number {\n    return this._contentLength ?? 0;\n  }\n\n  /**\n   * Whether a content length has been observed\n   */\n  hasContentLength(): boolean {\n    return this._contentLength != null;\n  }\n\n  /**\n   * Finds the flow-relative offset (e.g. starting from the left in LTR, but\n   * right in RTL) from a layout box.\n   */\n  flowRelativeOffset(\n    layout: LayoutRectangle,\n    referenceContentLength?: ?number,\n  ): number {\n    const {horizontal, rtl} = this._orientation;\n\n    if (horizontal && rtl) {\n      const contentLength = referenceContentLength ?? this._contentLength;\n      invariant(\n        contentLength != null,\n        'ListMetricsAggregator must be notified of list content layout before resolving offsets',\n      );\n      return (\n        contentLength -\n        (this._selectOffset(layout) + this._selectLength(layout))\n      );\n    } else {\n      return this._selectOffset(layout);\n    }\n  }\n\n  /**\n   * Converts a flow-relative offset to a cartesian offset\n   */\n  cartesianOffset(flowRelativeOffset: number): number {\n    const {horizontal, rtl} = this._orientation;\n\n    if (horizontal && rtl) {\n      invariant(\n        this._contentLength != null,\n        'ListMetricsAggregator must be notified of list content layout before resolving offsets',\n      );\n      return this._contentLength - flowRelativeOffset;\n    } else {\n      return flowRelativeOffset;\n    }\n  }\n\n  _invalidateIfOrientationChanged(orientation: ListOrientation): void {\n    if (orientation.rtl !== this._orientation.rtl) {\n      this._cellMetrics.clear();\n    }\n\n    if (orientation.horizontal !== this._orientation.horizontal) {\n      this._averageCellLength = 0;\n      this._highestMeasuredCellIndex = 0;\n      this._measuredCellsLength = 0;\n      this._measuredCellsCount = 0;\n    }\n\n    this._orientation = orientation;\n  }\n\n  _selectLength({\n    width,\n    height,\n  }: $ReadOnly<{width: number, height: number, ...}>): number {\n    return this._orientation.horizontal ? width : height;\n  }\n\n  _selectOffset({x, y}: $ReadOnly<{x: number, y: number, ...}>): number {\n    return this._orientation.horizontal ? x : y;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}