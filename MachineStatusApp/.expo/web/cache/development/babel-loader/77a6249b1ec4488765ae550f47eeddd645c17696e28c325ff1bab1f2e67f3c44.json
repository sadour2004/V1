{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nexports.getChildNodes = getChildNodes;\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar ReactNativeFeatureFlags = _interopRequireWildcard(require(\"../../../featureflags/ReactNativeFeatureFlags\"));\nvar _NodeList = require(\"../oldstylecollections/NodeList\");\nvar _NodeInternals = require(\"./internals/NodeInternals\");\nvar _NativeDOM = _interopRequireDefault(require(\"./specs/NativeDOM\"));\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) \"default\" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }\nvar ReadOnlyNode = exports.default = function () {\n  function ReadOnlyNode(instanceHandle, ownerDocument) {\n    (0, _classCallCheck2.default)(this, ReadOnlyNode);\n    (0, _NodeInternals.setOwnerDocument)(this, ownerDocument);\n    (0, _NodeInternals.setInstanceHandle)(this, instanceHandle);\n  }\n  return (0, _createClass2.default)(ReadOnlyNode, [{\n    key: \"childNodes\",\n    get: function get() {\n      var childNodes = getChildNodes(this);\n      return (0, _NodeList.createNodeList)(childNodes);\n    }\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      var childNodes = getChildNodes(this);\n      if (childNodes.length === 0) {\n        return null;\n      }\n      return childNodes[0];\n    }\n  }, {\n    key: \"isConnected\",\n    get: function get() {\n      var shadowNode = (0, _NodeInternals.getNativeNodeReference)(this);\n      if (shadowNode == null) {\n        return false;\n      }\n      return _NativeDOM.default.isConnected(shadowNode);\n    }\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      var childNodes = getChildNodes(this);\n      if (childNodes.length === 0) {\n        return null;\n      }\n      return childNodes[childNodes.length - 1];\n    }\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      var _getNodeSiblingsAndPo = getNodeSiblingsAndPosition(this),\n        _getNodeSiblingsAndPo2 = (0, _slicedToArray2.default)(_getNodeSiblingsAndPo, 2),\n        siblings = _getNodeSiblingsAndPo2[0],\n        position = _getNodeSiblingsAndPo2[1];\n      if (position === siblings.length - 1) {\n        return null;\n      }\n      return siblings[position + 1];\n    }\n  }, {\n    key: \"nodeName\",\n    get: function get() {\n      throw new TypeError('`nodeName` is abstract and must be implemented in a subclass of `ReadOnlyNode`');\n    }\n  }, {\n    key: \"nodeType\",\n    get: function get() {\n      throw new TypeError('`nodeType` is abstract and must be implemented in a subclass of `ReadOnlyNode`');\n    }\n  }, {\n    key: \"nodeValue\",\n    get: function get() {\n      throw new TypeError('`nodeValue` is abstract and must be implemented in a subclass of `ReadOnlyNode`');\n    }\n  }, {\n    key: \"ownerDocument\",\n    get: function get() {\n      return (0, _NodeInternals.getOwnerDocument)(this);\n    }\n  }, {\n    key: \"parentElement\",\n    get: function get() {\n      var parentNode = this.parentNode;\n      if (parentNode instanceof getReadOnlyElementClass()) {\n        return parentNode;\n      }\n      return null;\n    }\n  }, {\n    key: \"parentNode\",\n    get: function get() {\n      var _getPublicInstanceFro;\n      var shadowNode = (0, _NodeInternals.getNativeNodeReference)(this);\n      if (shadowNode == null) {\n        return null;\n      }\n      var parentInstanceHandle = _NativeDOM.default.getParentNode(shadowNode);\n      if (parentInstanceHandle == null) {\n        return null;\n      }\n      return (_getPublicInstanceFro = (0, _NodeInternals.getPublicInstanceFromInstanceHandle)(parentInstanceHandle)) != null ? _getPublicInstanceFro : null;\n    }\n  }, {\n    key: \"previousSibling\",\n    get: function get() {\n      var _getNodeSiblingsAndPo3 = getNodeSiblingsAndPosition(this),\n        _getNodeSiblingsAndPo4 = (0, _slicedToArray2.default)(_getNodeSiblingsAndPo3, 2),\n        siblings = _getNodeSiblingsAndPo4[0],\n        position = _getNodeSiblingsAndPo4[1];\n      if (position === 0) {\n        return null;\n      }\n      return siblings[position - 1];\n    }\n  }, {\n    key: \"textContent\",\n    get: function get() {\n      throw new TypeError('`textContent` is abstract and must be implemented in a subclass of `ReadOnlyNode`');\n    }\n  }, {\n    key: \"compareDocumentPosition\",\n    value: function compareDocumentPosition(otherNode) {\n      if (otherNode === this) {\n        return 0;\n      }\n      var shadowNode = (0, _NodeInternals.getNativeNodeReference)(this);\n      var otherShadowNode = (0, _NodeInternals.getNativeNodeReference)(otherNode);\n      if (shadowNode == null || otherShadowNode == null) {\n        return ReadOnlyNode.DOCUMENT_POSITION_DISCONNECTED;\n      }\n      return _NativeDOM.default.compareDocumentPosition(shadowNode, otherShadowNode);\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(otherNode) {\n      if (otherNode === this) {\n        return true;\n      }\n      var position = this.compareDocumentPosition(otherNode);\n      return (position & ReadOnlyNode.DOCUMENT_POSITION_CONTAINED_BY) !== 0;\n    }\n  }, {\n    key: \"getRootNode\",\n    value: function getRootNode() {\n      if (ReactNativeFeatureFlags.enableDOMDocumentAPI()) {\n        if (this.isConnected) {\n          var _this$ownerDocument;\n          return (_this$ownerDocument = this.ownerDocument) != null ? _this$ownerDocument : this;\n        }\n        return this;\n      } else {\n        var lastKnownParent = this;\n        var nextPossibleParent = this.parentNode;\n        while (nextPossibleParent != null) {\n          lastKnownParent = nextPossibleParent;\n          nextPossibleParent = nextPossibleParent.parentNode;\n        }\n        return lastKnownParent;\n      }\n    }\n  }, {\n    key: \"hasChildNodes\",\n    value: function hasChildNodes() {\n      return getChildNodes(this).length > 0;\n    }\n  }]);\n}();\nReadOnlyNode.ELEMENT_NODE = 1;\nReadOnlyNode.ATTRIBUTE_NODE = 2;\nReadOnlyNode.TEXT_NODE = 3;\nReadOnlyNode.CDATA_SECTION_NODE = 4;\nReadOnlyNode.ENTITY_REFERENCE_NODE = 5;\nReadOnlyNode.ENTITY_NODE = 6;\nReadOnlyNode.PROCESSING_INSTRUCTION_NODE = 7;\nReadOnlyNode.COMMENT_NODE = 8;\nReadOnlyNode.DOCUMENT_NODE = 9;\nReadOnlyNode.DOCUMENT_TYPE_NODE = 10;\nReadOnlyNode.DOCUMENT_FRAGMENT_NODE = 11;\nReadOnlyNode.NOTATION_NODE = 12;\nReadOnlyNode.DOCUMENT_POSITION_DISCONNECTED = 1;\nReadOnlyNode.DOCUMENT_POSITION_PRECEDING = 2;\nReadOnlyNode.DOCUMENT_POSITION_FOLLOWING = 4;\nReadOnlyNode.DOCUMENT_POSITION_CONTAINS = 8;\nReadOnlyNode.DOCUMENT_POSITION_CONTAINED_BY = 16;\nReadOnlyNode.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;\nfunction getChildNodes(node) {\n  var shadowNode = (0, _NodeInternals.getNativeNodeReference)(node);\n  if (shadowNode == null) {\n    return [];\n  }\n  var childNodeInstanceHandles = _NativeDOM.default.getChildNodes(shadowNode);\n  return childNodeInstanceHandles.map(function (instanceHandle) {\n    return (0, _NodeInternals.getPublicInstanceFromInstanceHandle)(instanceHandle);\n  }).filter(Boolean);\n}\nfunction getNodeSiblingsAndPosition(node) {\n  var parent = node.parentNode;\n  if (parent == null) {\n    return [[node], 0];\n  }\n  var siblings = getChildNodes(parent);\n  var position = siblings.indexOf(node);\n  if (position === -1) {\n    throw new TypeError(\"Missing node in parent's child node list\");\n  }\n  return [siblings, position];\n}\nvar ReadOnlyElementClass;\nfunction getReadOnlyElementClass() {\n  if (ReadOnlyElementClass == null) {\n    ReadOnlyElementClass = require('./ReadOnlyElement').default;\n  }\n  return ReadOnlyElementClass;\n}","map":{"version":3,"names":["ReactNativeFeatureFlags","_interopRequireWildcard","require","_NodeList","_NodeInternals","_NativeDOM","_interopRequireDefault","e","t","WeakMap","r","n","__esModule","o","i","f","__proto__","default","has","get","set","_t","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","ReadOnlyNode","exports","instanceHandle","ownerDocument","_classCallCheck2","setOwnerDocument","setInstanceHandle","_createClass2","key","childNodes","getChildNodes","createNodeList","length","shadowNode","getNativeNodeReference","NativeDOM","isConnected","_getNodeSiblingsAndPo","getNodeSiblingsAndPosition","_getNodeSiblingsAndPo2","_slicedToArray2","siblings","position","TypeError","getOwnerDocument","parentNode","getReadOnlyElementClass","_getPublicInstanceFro","parentInstanceHandle","getParentNode","getPublicInstanceFromInstanceHandle","_getNodeSiblingsAndPo3","_getNodeSiblingsAndPo4","value","compareDocumentPosition","otherNode","otherShadowNode","DOCUMENT_POSITION_DISCONNECTED","contains","DOCUMENT_POSITION_CONTAINED_BY","getRootNode","enableDOMDocumentAPI","_this$ownerDocument","lastKnownParent","nextPossibleParent","hasChildNodes","ELEMENT_NODE","ATTRIBUTE_NODE","TEXT_NODE","CDATA_SECTION_NODE","ENTITY_REFERENCE_NODE","ENTITY_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","DOCUMENT_FRAGMENT_NODE","NOTATION_NODE","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_CONTAINS","DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC","node","childNodeInstanceHandles","map","filter","Boolean","parent","indexOf","ReadOnlyElementClass"],"sources":["/Users/ayoubsadour/Desktop/APPMOBILE/MachineStatusApp/node_modules/react-native/src/private/webapis/dom/nodes/ReadOnlyNode.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict-local\n */\n\n// flowlint unsafe-getters-setters:off\n\nimport type NodeList from '../oldstylecollections/NodeList';\nimport type {InstanceHandle} from './internals/NodeInternals';\nimport type ReactNativeDocument from './ReactNativeDocument';\nimport type ReadOnlyElement from './ReadOnlyElement';\n\nimport * as ReactNativeFeatureFlags from '../../../featureflags/ReactNativeFeatureFlags';\nimport {createNodeList} from '../oldstylecollections/NodeList';\nimport {\n  getNativeNodeReference,\n  getOwnerDocument,\n  getPublicInstanceFromInstanceHandle,\n  setInstanceHandle,\n  setOwnerDocument,\n} from './internals/NodeInternals';\nimport NativeDOM from './specs/NativeDOM';\n\nexport default class ReadOnlyNode {\n  constructor(\n    instanceHandle: InstanceHandle,\n    // This will be null for the document node itself.\n    ownerDocument: ReactNativeDocument | null,\n  ) {\n    // This constructor is inlined in `ReactNativeElement` so if you modify\n    // this make sure that their implementation stays in sync.\n    setOwnerDocument(this, ownerDocument);\n    setInstanceHandle(this, instanceHandle);\n  }\n\n  get childNodes(): NodeList<ReadOnlyNode> {\n    const childNodes = getChildNodes(this);\n    return createNodeList(childNodes);\n  }\n\n  get firstChild(): ReadOnlyNode | null {\n    const childNodes = getChildNodes(this);\n\n    if (childNodes.length === 0) {\n      return null;\n    }\n\n    return childNodes[0];\n  }\n\n  get isConnected(): boolean {\n    const shadowNode = getNativeNodeReference(this);\n\n    if (shadowNode == null) {\n      return false;\n    }\n\n    return NativeDOM.isConnected(shadowNode);\n  }\n\n  get lastChild(): ReadOnlyNode | null {\n    const childNodes = getChildNodes(this);\n\n    if (childNodes.length === 0) {\n      return null;\n    }\n\n    return childNodes[childNodes.length - 1];\n  }\n\n  get nextSibling(): ReadOnlyNode | null {\n    const [siblings, position] = getNodeSiblingsAndPosition(this);\n\n    if (position === siblings.length - 1) {\n      // this node is the last child of its parent, so there is no next sibling.\n      return null;\n    }\n\n    return siblings[position + 1];\n  }\n\n  /**\n   * @abstract\n   */\n  get nodeName(): string {\n    throw new TypeError(\n      '`nodeName` is abstract and must be implemented in a subclass of `ReadOnlyNode`',\n    );\n  }\n\n  /**\n   * @abstract\n   */\n  get nodeType(): number {\n    throw new TypeError(\n      '`nodeType` is abstract and must be implemented in a subclass of `ReadOnlyNode`',\n    );\n  }\n\n  /**\n   * @abstract\n   */\n  get nodeValue(): string | null {\n    throw new TypeError(\n      '`nodeValue` is abstract and must be implemented in a subclass of `ReadOnlyNode`',\n    );\n  }\n\n  get ownerDocument(): ReactNativeDocument | null {\n    return getOwnerDocument(this);\n  }\n\n  get parentElement(): ReadOnlyElement | null {\n    const parentNode = this.parentNode;\n\n    if (parentNode instanceof getReadOnlyElementClass()) {\n      return parentNode;\n    }\n\n    return null;\n  }\n\n  get parentNode(): ReadOnlyNode | null {\n    const shadowNode = getNativeNodeReference(this);\n\n    if (shadowNode == null) {\n      return null;\n    }\n\n    const parentInstanceHandle = NativeDOM.getParentNode(shadowNode);\n\n    if (parentInstanceHandle == null) {\n      return null;\n    }\n\n    return getPublicInstanceFromInstanceHandle(parentInstanceHandle) ?? null;\n  }\n\n  get previousSibling(): ReadOnlyNode | null {\n    const [siblings, position] = getNodeSiblingsAndPosition(this);\n\n    if (position === 0) {\n      // this node is the first child of its parent, so there is no previous sibling.\n      return null;\n    }\n\n    return siblings[position - 1];\n  }\n\n  /**\n   * @abstract\n   */\n  get textContent(): string {\n    throw new TypeError(\n      '`textContent` is abstract and must be implemented in a subclass of `ReadOnlyNode`',\n    );\n  }\n\n  compareDocumentPosition(otherNode: ReadOnlyNode): number {\n    // Quick check to avoid having to call into Fabric if the nodes are the same.\n    if (otherNode === this) {\n      return 0;\n    }\n\n    const shadowNode = getNativeNodeReference(this);\n    const otherShadowNode = getNativeNodeReference(otherNode);\n\n    if (shadowNode == null || otherShadowNode == null) {\n      return ReadOnlyNode.DOCUMENT_POSITION_DISCONNECTED;\n    }\n\n    return NativeDOM.compareDocumentPosition(shadowNode, otherShadowNode);\n  }\n\n  contains(otherNode: ReadOnlyNode): boolean {\n    if (otherNode === this) {\n      return true;\n    }\n\n    const position = this.compareDocumentPosition(otherNode);\n    // eslint-disable-next-line no-bitwise\n    return (position & ReadOnlyNode.DOCUMENT_POSITION_CONTAINED_BY) !== 0;\n  }\n\n  getRootNode(): ReadOnlyNode {\n    if (ReactNativeFeatureFlags.enableDOMDocumentAPI()) {\n      if (this.isConnected) {\n        // If this is the document node, then the root node is itself.\n        return this.ownerDocument ?? this;\n      }\n\n      return this;\n    } else {\n      // eslint-disable-next-line consistent-this\n      let lastKnownParent: ReadOnlyNode = this;\n      let nextPossibleParent: ?ReadOnlyNode = this.parentNode;\n\n      while (nextPossibleParent != null) {\n        lastKnownParent = nextPossibleParent;\n        nextPossibleParent = nextPossibleParent.parentNode;\n      }\n\n      return lastKnownParent;\n    }\n  }\n\n  hasChildNodes(): boolean {\n    return getChildNodes(this).length > 0;\n  }\n\n  /*\n   * Node types, as returned by the `nodeType` property.\n   */\n\n  /**\n   * Type of Element, HTMLElement and ReactNativeElement instances.\n   */\n  static ELEMENT_NODE: number = 1;\n  /**\n   * Currently Unused in React Native.\n   */\n  static ATTRIBUTE_NODE: number = 2;\n  /**\n   * Text nodes.\n   */\n  static TEXT_NODE: number = 3;\n  /**\n   * @deprecated Unused in React Native.\n   */\n  static CDATA_SECTION_NODE: number = 4;\n  /**\n   * @deprecated\n   */\n  static ENTITY_REFERENCE_NODE: number = 5;\n  /**\n   * @deprecated\n   */\n  static ENTITY_NODE: number = 6;\n  /**\n   * @deprecated Unused in React Native.\n   */\n  static PROCESSING_INSTRUCTION_NODE: number = 7;\n  /**\n   * @deprecated Unused in React Native.\n   */\n  static COMMENT_NODE: number = 8;\n  /**\n   * Document nodes.\n   */\n  static DOCUMENT_NODE: number = 9;\n  /**\n   * @deprecated Unused in React Native.\n   */\n  static DOCUMENT_TYPE_NODE: number = 10;\n  /**\n   * @deprecated Unused in React Native.\n   */\n  static DOCUMENT_FRAGMENT_NODE: number = 11;\n  /**\n   * @deprecated\n   */\n  static NOTATION_NODE: number = 12;\n\n  /*\n   * Document position flags. Used to check the return value of\n   * `compareDocumentPosition()`.\n   */\n\n  /**\n   * Both nodes are in different documents.\n   */\n  static DOCUMENT_POSITION_DISCONNECTED: number = 1;\n  /**\n   * `otherNode` precedes the node in either a pre-order depth-first traversal of a tree containing both\n   * (e.g., as an ancestor or previous sibling or a descendant of a previous sibling or previous sibling of an ancestor)\n   * or (if they are disconnected) in an arbitrary but consistent ordering.\n   */\n  static DOCUMENT_POSITION_PRECEDING: number = 2;\n  /**\n   * `otherNode` follows the node in either a pre-order depth-first traversal of a tree containing both\n   * (e.g., as a descendant or following sibling or a descendant of a following sibling or following sibling of an ancestor)\n   * or (if they are disconnected) in an arbitrary but consistent ordering.\n   */\n  static DOCUMENT_POSITION_FOLLOWING: number = 4;\n  /**\n   * `otherNode` is an ancestor of the node.\n   */\n  static DOCUMENT_POSITION_CONTAINS: number = 8;\n  /**\n   * `otherNode` is a descendant of the node.\n   */\n  static DOCUMENT_POSITION_CONTAINED_BY: number = 16;\n  /**\n   * @deprecated Unused in React Native.\n   */\n  static DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number = 32;\n}\n\nexport function getChildNodes(\n  node: ReadOnlyNode,\n): $ReadOnlyArray<ReadOnlyNode> {\n  const shadowNode = getNativeNodeReference(node);\n\n  if (shadowNode == null) {\n    return [];\n  }\n\n  const childNodeInstanceHandles = NativeDOM.getChildNodes(shadowNode);\n  return childNodeInstanceHandles\n    .map(instanceHandle => getPublicInstanceFromInstanceHandle(instanceHandle))\n    .filter(Boolean);\n}\n\nfunction getNodeSiblingsAndPosition(\n  node: ReadOnlyNode,\n): [$ReadOnlyArray<ReadOnlyNode>, number] {\n  const parent = node.parentNode;\n  if (parent == null) {\n    // This node is the root or it's disconnected.\n    return [[node], 0];\n  }\n\n  const siblings = getChildNodes(parent);\n  const position = siblings.indexOf(node);\n\n  if (position === -1) {\n    throw new TypeError(\"Missing node in parent's child node list\");\n  }\n\n  return [siblings, position];\n}\n\nlet ReadOnlyElementClass;\nfunction getReadOnlyElementClass(): Class<ReadOnlyElement> {\n  if (ReadOnlyElementClass == null) {\n    // We initialize this lazily to avoid a require cycle.\n    ReadOnlyElementClass = require('./ReadOnlyElement').default;\n  }\n  return ReadOnlyElementClass;\n}\n"],"mappings":";;;;;;;;;AAiBA,IAAAA,uBAAA,GAAAC,uBAAA,CAAAC,OAAA;AACA,IAAAC,SAAA,GAAAD,OAAA;AACA,IAAAE,cAAA,GAAAF,OAAA;AAOA,IAAAG,UAAA,GAAAC,sBAAA,CAAAJ,OAAA;AAA0C,SAAAD,wBAAAM,CAAA,EAAAC,CAAA,6BAAAC,OAAA,MAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAR,uBAAA,YAAAA,wBAAAM,CAAA,EAAAC,CAAA,SAAAA,CAAA,IAAAD,CAAA,IAAAA,CAAA,CAAAK,UAAA,SAAAL,CAAA,MAAAM,CAAA,EAAAC,CAAA,EAAAC,CAAA,KAAAC,SAAA,QAAAC,OAAA,EAAAV,CAAA,iBAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,SAAAQ,CAAA,MAAAF,CAAA,GAAAL,CAAA,GAAAG,CAAA,GAAAD,CAAA,QAAAG,CAAA,CAAAK,GAAA,CAAAX,CAAA,UAAAM,CAAA,CAAAM,GAAA,CAAAZ,CAAA,GAAAM,CAAA,CAAAO,GAAA,CAAAb,CAAA,EAAAQ,CAAA,cAAAM,EAAA,IAAAd,CAAA,gBAAAc,EAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,EAAA,OAAAP,CAAA,IAAAD,CAAA,GAAAW,MAAA,CAAAC,cAAA,KAAAD,MAAA,CAAAE,wBAAA,CAAAnB,CAAA,EAAAc,EAAA,OAAAP,CAAA,CAAAK,GAAA,IAAAL,CAAA,CAAAM,GAAA,IAAAP,CAAA,CAAAE,CAAA,EAAAM,EAAA,EAAAP,CAAA,IAAAC,CAAA,CAAAM,EAAA,IAAAd,CAAA,CAAAc,EAAA,WAAAN,CAAA,KAAAR,CAAA,EAAAC,CAAA;AAAA,IAErBmB,YAAY,GAAAC,OAAA,CAAAX,OAAA;EAC/B,SAAAU,aACEE,cAA8B,EAE9BC,aAAyC,EACzC;IAAA,IAAAC,gBAAA,CAAAd,OAAA,QAAAU,YAAA;IAGA,IAAAK,+BAAgB,EAAC,IAAI,EAAEF,aAAa,CAAC;IACrC,IAAAG,gCAAiB,EAAC,IAAI,EAAEJ,cAAc,CAAC;EACzC;EAAC,WAAAK,aAAA,CAAAjB,OAAA,EAAAU,YAAA;IAAAQ,GAAA;IAAAhB,GAAA,EAED,SAAAA,IAAA,EAAyC;MACvC,IAAMiB,UAAU,GAAGC,aAAa,CAAC,IAAI,CAAC;MACtC,OAAO,IAAAC,wBAAc,EAACF,UAAU,CAAC;IACnC;EAAC;IAAAD,GAAA;IAAAhB,GAAA,EAED,SAAAA,IAAA,EAAsC;MACpC,IAAMiB,UAAU,GAAGC,aAAa,CAAC,IAAI,CAAC;MAEtC,IAAID,UAAU,CAACG,MAAM,KAAK,CAAC,EAAE;QAC3B,OAAO,IAAI;MACb;MAEA,OAAOH,UAAU,CAAC,CAAC,CAAC;IACtB;EAAC;IAAAD,GAAA;IAAAhB,GAAA,EAED,SAAAA,IAAA,EAA2B;MACzB,IAAMqB,UAAU,GAAG,IAAAC,qCAAsB,EAAC,IAAI,CAAC;MAE/C,IAAID,UAAU,IAAI,IAAI,EAAE;QACtB,OAAO,KAAK;MACd;MAEA,OAAOE,kBAAS,CAACC,WAAW,CAACH,UAAU,CAAC;IAC1C;EAAC;IAAAL,GAAA;IAAAhB,GAAA,EAED,SAAAA,IAAA,EAAqC;MACnC,IAAMiB,UAAU,GAAGC,aAAa,CAAC,IAAI,CAAC;MAEtC,IAAID,UAAU,CAACG,MAAM,KAAK,CAAC,EAAE;QAC3B,OAAO,IAAI;MACb;MAEA,OAAOH,UAAU,CAACA,UAAU,CAACG,MAAM,GAAG,CAAC,CAAC;IAC1C;EAAC;IAAAJ,GAAA;IAAAhB,GAAA,EAED,SAAAA,IAAA,EAAuC;MACrC,IAAAyB,qBAAA,GAA6BC,0BAA0B,CAAC,IAAI,CAAC;QAAAC,sBAAA,OAAAC,eAAA,CAAA9B,OAAA,EAAA2B,qBAAA;QAAtDI,QAAQ,GAAAF,sBAAA;QAAEG,QAAQ,GAAAH,sBAAA;MAEzB,IAAIG,QAAQ,KAAKD,QAAQ,CAACT,MAAM,GAAG,CAAC,EAAE;QAEpC,OAAO,IAAI;MACb;MAEA,OAAOS,QAAQ,CAACC,QAAQ,GAAG,CAAC,CAAC;IAC/B;EAAC;IAAAd,GAAA;IAAAhB,GAAA,EAKD,SAAAA,IAAA,EAAuB;MACrB,MAAM,IAAI+B,SAAS,CACjB,gFACF,CAAC;IACH;EAAC;IAAAf,GAAA;IAAAhB,GAAA,EAKD,SAAAA,IAAA,EAAuB;MACrB,MAAM,IAAI+B,SAAS,CACjB,gFACF,CAAC;IACH;EAAC;IAAAf,GAAA;IAAAhB,GAAA,EAKD,SAAAA,IAAA,EAA+B;MAC7B,MAAM,IAAI+B,SAAS,CACjB,iFACF,CAAC;IACH;EAAC;IAAAf,GAAA;IAAAhB,GAAA,EAED,SAAAA,IAAA,EAAgD;MAC9C,OAAO,IAAAgC,+BAAgB,EAAC,IAAI,CAAC;IAC/B;EAAC;IAAAhB,GAAA;IAAAhB,GAAA,EAED,SAAAA,IAAA,EAA4C;MAC1C,IAAMiC,UAAU,GAAG,IAAI,CAACA,UAAU;MAElC,IAAIA,UAAU,YAAYC,uBAAuB,CAAC,CAAC,EAAE;QACnD,OAAOD,UAAU;MACnB;MAEA,OAAO,IAAI;IACb;EAAC;IAAAjB,GAAA;IAAAhB,GAAA,EAED,SAAAA,IAAA,EAAsC;MAAA,IAAAmC,qBAAA;MACpC,IAAMd,UAAU,GAAG,IAAAC,qCAAsB,EAAC,IAAI,CAAC;MAE/C,IAAID,UAAU,IAAI,IAAI,EAAE;QACtB,OAAO,IAAI;MACb;MAEA,IAAMe,oBAAoB,GAAGb,kBAAS,CAACc,aAAa,CAAChB,UAAU,CAAC;MAEhE,IAAIe,oBAAoB,IAAI,IAAI,EAAE;QAChC,OAAO,IAAI;MACb;MAEA,QAAAD,qBAAA,GAAO,IAAAG,kDAAmC,EAACF,oBAAoB,CAAC,YAAAD,qBAAA,GAAI,IAAI;IAC1E;EAAC;IAAAnB,GAAA;IAAAhB,GAAA,EAED,SAAAA,IAAA,EAA2C;MACzC,IAAAuC,sBAAA,GAA6Bb,0BAA0B,CAAC,IAAI,CAAC;QAAAc,sBAAA,OAAAZ,eAAA,CAAA9B,OAAA,EAAAyC,sBAAA;QAAtDV,QAAQ,GAAAW,sBAAA;QAAEV,QAAQ,GAAAU,sBAAA;MAEzB,IAAIV,QAAQ,KAAK,CAAC,EAAE;QAElB,OAAO,IAAI;MACb;MAEA,OAAOD,QAAQ,CAACC,QAAQ,GAAG,CAAC,CAAC;IAC/B;EAAC;IAAAd,GAAA;IAAAhB,GAAA,EAKD,SAAAA,IAAA,EAA0B;MACxB,MAAM,IAAI+B,SAAS,CACjB,mFACF,CAAC;IACH;EAAC;IAAAf,GAAA;IAAAyB,KAAA,EAED,SAAAC,uBAAuBA,CAACC,SAAuB,EAAU;MAEvD,IAAIA,SAAS,KAAK,IAAI,EAAE;QACtB,OAAO,CAAC;MACV;MAEA,IAAMtB,UAAU,GAAG,IAAAC,qCAAsB,EAAC,IAAI,CAAC;MAC/C,IAAMsB,eAAe,GAAG,IAAAtB,qCAAsB,EAACqB,SAAS,CAAC;MAEzD,IAAItB,UAAU,IAAI,IAAI,IAAIuB,eAAe,IAAI,IAAI,EAAE;QACjD,OAAOpC,YAAY,CAACqC,8BAA8B;MACpD;MAEA,OAAOtB,kBAAS,CAACmB,uBAAuB,CAACrB,UAAU,EAAEuB,eAAe,CAAC;IACvE;EAAC;IAAA5B,GAAA;IAAAyB,KAAA,EAED,SAAAK,QAAQA,CAACH,SAAuB,EAAW;MACzC,IAAIA,SAAS,KAAK,IAAI,EAAE;QACtB,OAAO,IAAI;MACb;MAEA,IAAMb,QAAQ,GAAG,IAAI,CAACY,uBAAuB,CAACC,SAAS,CAAC;MAExD,OAAO,CAACb,QAAQ,GAAGtB,YAAY,CAACuC,8BAA8B,MAAM,CAAC;IACvE;EAAC;IAAA/B,GAAA;IAAAyB,KAAA,EAED,SAAAO,WAAWA,CAAA,EAAiB;MAC1B,IAAInE,uBAAuB,CAACoE,oBAAoB,CAAC,CAAC,EAAE;QAClD,IAAI,IAAI,CAACzB,WAAW,EAAE;UAAA,IAAA0B,mBAAA;UAEpB,QAAAA,mBAAA,GAAO,IAAI,CAACvC,aAAa,YAAAuC,mBAAA,GAAI,IAAI;QACnC;QAEA,OAAO,IAAI;MACb,CAAC,MAAM;QAEL,IAAIC,eAA6B,GAAG,IAAI;QACxC,IAAIC,kBAAiC,GAAG,IAAI,CAACnB,UAAU;QAEvD,OAAOmB,kBAAkB,IAAI,IAAI,EAAE;UACjCD,eAAe,GAAGC,kBAAkB;UACpCA,kBAAkB,GAAGA,kBAAkB,CAACnB,UAAU;QACpD;QAEA,OAAOkB,eAAe;MACxB;IACF;EAAC;IAAAnC,GAAA;IAAAyB,KAAA,EAED,SAAAY,aAAaA,CAAA,EAAY;MACvB,OAAOnC,aAAa,CAAC,IAAI,CAAC,CAACE,MAAM,GAAG,CAAC;IACvC;EAAC;AAAA;AAzLkBZ,YAAY,CAkMxB8C,YAAY,GAAW,CAAC;AAlMZ9C,YAAY,CAsMxB+C,cAAc,GAAW,CAAC;AAtMd/C,YAAY,CA0MxBgD,SAAS,GAAW,CAAC;AA1MThD,YAAY,CA8MxBiD,kBAAkB,GAAW,CAAC;AA9MlBjD,YAAY,CAkNxBkD,qBAAqB,GAAW,CAAC;AAlNrBlD,YAAY,CAsNxBmD,WAAW,GAAW,CAAC;AAtNXnD,YAAY,CA0NxBoD,2BAA2B,GAAW,CAAC;AA1N3BpD,YAAY,CA8NxBqD,YAAY,GAAW,CAAC;AA9NZrD,YAAY,CAkOxBsD,aAAa,GAAW,CAAC;AAlObtD,YAAY,CAsOxBuD,kBAAkB,GAAW,EAAE;AAtOnBvD,YAAY,CA0OxBwD,sBAAsB,GAAW,EAAE;AA1OvBxD,YAAY,CA8OxByD,aAAa,GAAW,EAAE;AA9OdzD,YAAY,CAwPxBqC,8BAA8B,GAAW,CAAC;AAxP9BrC,YAAY,CA8PxB0D,2BAA2B,GAAW,CAAC;AA9P3B1D,YAAY,CAoQxB2D,2BAA2B,GAAW,CAAC;AApQ3B3D,YAAY,CAwQxB4D,0BAA0B,GAAW,CAAC;AAxQ1B5D,YAAY,CA4QxBuC,8BAA8B,GAAW,EAAE;AA5Q/BvC,YAAY,CAgRxB6D,yCAAyC,GAAW,EAAE;AAGxD,SAASnD,aAAaA,CAC3BoD,IAAkB,EACY;EAC9B,IAAMjD,UAAU,GAAG,IAAAC,qCAAsB,EAACgD,IAAI,CAAC;EAE/C,IAAIjD,UAAU,IAAI,IAAI,EAAE;IACtB,OAAO,EAAE;EACX;EAEA,IAAMkD,wBAAwB,GAAGhD,kBAAS,CAACL,aAAa,CAACG,UAAU,CAAC;EACpE,OAAOkD,wBAAwB,CAC5BC,GAAG,CAAC,UAAA9D,cAAc;IAAA,OAAI,IAAA4B,kDAAmC,EAAC5B,cAAc,CAAC;EAAA,EAAC,CAC1E+D,MAAM,CAACC,OAAO,CAAC;AACpB;AAEA,SAAShD,0BAA0BA,CACjC4C,IAAkB,EACsB;EACxC,IAAMK,MAAM,GAAGL,IAAI,CAACrC,UAAU;EAC9B,IAAI0C,MAAM,IAAI,IAAI,EAAE;IAElB,OAAO,CAAC,CAACL,IAAI,CAAC,EAAE,CAAC,CAAC;EACpB;EAEA,IAAMzC,QAAQ,GAAGX,aAAa,CAACyD,MAAM,CAAC;EACtC,IAAM7C,QAAQ,GAAGD,QAAQ,CAAC+C,OAAO,CAACN,IAAI,CAAC;EAEvC,IAAIxC,QAAQ,KAAK,CAAC,CAAC,EAAE;IACnB,MAAM,IAAIC,SAAS,CAAC,0CAA0C,CAAC;EACjE;EAEA,OAAO,CAACF,QAAQ,EAAEC,QAAQ,CAAC;AAC7B;AAEA,IAAI+C,oBAAoB;AACxB,SAAS3C,uBAAuBA,CAAA,EAA2B;EACzD,IAAI2C,oBAAoB,IAAI,IAAI,EAAE;IAEhCA,oBAAoB,GAAG9F,OAAO,CAAC,mBAAmB,CAAC,CAACe,OAAO;EAC7D;EACA,OAAO+E,oBAAoB;AAC7B","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}