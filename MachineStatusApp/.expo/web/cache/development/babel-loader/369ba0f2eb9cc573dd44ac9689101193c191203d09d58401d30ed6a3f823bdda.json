{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar invariant = require('invariant');\nfunction reject(error) {\n  setTimeout(function () {\n    throw error;\n  }, 0);\n}\nvar InteractionManagerStub = {\n  Events: {\n    interactionStart: 'interactionStart',\n    interactionComplete: 'interactionComplete'\n  },\n  runAfterInteractions: function runAfterInteractions(task) {\n    var immediateID;\n    var promise = new Promise(function (resolve) {\n      immediateID = setImmediate(function () {\n        if (typeof task === 'object' && task !== null) {\n          if (typeof task.gen === 'function') {\n            task.gen().then(resolve, reject);\n          } else if (typeof task.run === 'function') {\n            try {\n              task.run();\n              resolve();\n            } catch (error) {\n              reject(error);\n            }\n          } else {\n            reject(new TypeError(`Task \"${task.name}\" missing gen or run.`));\n          }\n        } else if (typeof task === 'function') {\n          try {\n            task();\n            resolve();\n          } catch (error) {\n            reject(error);\n          }\n        } else {\n          reject(new TypeError('Invalid task of type: ' + typeof task));\n        }\n      });\n    });\n    return {\n      then: promise.then.bind(promise),\n      cancel: function cancel() {\n        clearImmediate(immediateID);\n      }\n    };\n  },\n  createInteractionHandle: function createInteractionHandle() {\n    return -1;\n  },\n  clearInteractionHandle: function clearInteractionHandle(handle) {\n    invariant(!!handle, 'InteractionManager: Must provide a handle to clear.');\n  },\n  addListener: function addListener() {\n    return {\n      remove: function remove() {}\n    };\n  },\n  setDeadline: function setDeadline(deadline) {}\n};\nvar _default = exports.default = InteractionManagerStub;","map":{"version":3,"names":["invariant","require","reject","error","setTimeout","InteractionManagerStub","Events","interactionStart","interactionComplete","runAfterInteractions","task","immediateID","promise","Promise","resolve","setImmediate","gen","then","run","TypeError","name","bind","cancel","clearImmediate","createInteractionHandle","clearInteractionHandle","handle","addListener","remove","setDeadline","deadline","_default","exports","default"],"sources":["/Users/ayoubsadour/Desktop/APPMOBILE/MachineStatusApp/node_modules/react-native/Libraries/Interaction/InteractionManagerStub.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\nimport type {EventSubscription} from '../vendor/emitter/EventEmitter';\n\nconst invariant = require('invariant');\n\nexport type Handle = number;\n\ntype Task =\n  | {\n      name: string,\n      run: () => void,\n    }\n  | {\n      name: string,\n      gen: () => Promise<void>,\n    }\n  | (() => void);\n\n// NOTE: The original implementation of `InteractionManager` never rejected\n// the returned promise. This preserves that behavior in the stub.\nfunction reject(error: Error): void {\n  setTimeout(() => {\n    throw error;\n  }, 0);\n}\n\n/**\n * InteractionManager allows long-running work to be scheduled after any\n * interactions/animations have completed. In particular, this allows JavaScript\n * animations to run smoothly.\n *\n * Applications can schedule tasks to run after interactions with the following:\n *\n * ```\n * InteractionManager.runAfterInteractions(() => {\n *   // ...long-running synchronous task...\n * });\n * ```\n *\n * Compare this to other scheduling alternatives:\n *\n * - requestAnimationFrame(): for code that animates a view over time.\n * - setImmediate/setTimeout(): run code later, note this may delay animations.\n * - runAfterInteractions(): run code later, without delaying active animations.\n *\n * The touch handling system considers one or more active touches to be an\n * 'interaction' and will delay `runAfterInteractions()` callbacks until all\n * touches have ended or been cancelled.\n *\n * InteractionManager also allows applications to register animations by\n * creating an interaction 'handle' on animation start, and clearing it upon\n * completion:\n *\n * ```\n * var handle = InteractionManager.createInteractionHandle();\n * // run animation... (`runAfterInteractions` tasks are queued)\n * // later, on animation completion:\n * InteractionManager.clearInteractionHandle(handle);\n * // queued tasks run if all handles were cleared\n * ```\n *\n * `runAfterInteractions` takes either a plain callback function, or a\n * `PromiseTask` object with a `gen` method that returns a `Promise`.  If a\n * `PromiseTask` is supplied, then it is fully resolved (including asynchronous\n * dependencies that also schedule more tasks via `runAfterInteractions`) before\n * starting on the next task that might have been queued up synchronously\n * earlier.\n *\n * By default, queued tasks are executed together in a loop in one\n * `setImmediate` batch. If `setDeadline` is called with a positive number, then\n * tasks will only be executed until the deadline (in terms of js event loop run\n * time) approaches, at which point execution will yield via setTimeout,\n * allowing events such as touches to start interactions and block queued tasks\n * from executing, making apps more responsive.\n *\n * @deprecated\n */\nconst InteractionManagerStub = {\n  Events: {\n    interactionStart: 'interactionStart',\n    interactionComplete: 'interactionComplete',\n  },\n\n  /**\n   * Schedule a function to run after all interactions have completed. Returns a cancellable\n   * \"promise\".\n   *\n   * @deprecated\n   */\n  runAfterInteractions(task: ?Task): {\n    then: <U>(\n      onFulfill?: ?(void) => ?(Promise<U> | U),\n      onReject?: ?(error: mixed) => ?(Promise<U> | U),\n    ) => Promise<U>,\n    cancel: () => void,\n    ...\n  } {\n    let immediateID: ?$FlowIssue;\n    const promise = new Promise(resolve => {\n      immediateID = setImmediate(() => {\n        if (typeof task === 'object' && task !== null) {\n          if (typeof task.gen === 'function') {\n            task.gen().then(resolve, reject);\n          } else if (typeof task.run === 'function') {\n            try {\n              task.run();\n              resolve();\n            } catch (error) {\n              reject(error);\n            }\n          } else {\n            reject(new TypeError(`Task \"${task.name}\" missing gen or run.`));\n          }\n        } else if (typeof task === 'function') {\n          try {\n            task();\n            resolve();\n          } catch (error) {\n            reject(error);\n          }\n        } else {\n          reject(new TypeError('Invalid task of type: ' + typeof task));\n        }\n      });\n    });\n\n    return {\n      // $FlowFixMe[method-unbinding] added when improving typing for this parameters\n      then: promise.then.bind(promise),\n      cancel() {\n        clearImmediate(immediateID);\n      },\n    };\n  },\n\n  /**\n   * Notify manager that an interaction has started.\n   *\n   * @deprecated\n   */\n  createInteractionHandle(): Handle {\n    return -1;\n  },\n\n  /**\n   * Notify manager that an interaction has completed.\n   *\n   * @deprecated\n   */\n  clearInteractionHandle(handle: Handle) {\n    invariant(!!handle, 'InteractionManager: Must provide a handle to clear.');\n  },\n\n  /**\n   * @deprecated\n   */\n  addListener(): EventSubscription {\n    return {\n      remove() {},\n    };\n  },\n\n  /**\n   * A positive number will use setTimeout to schedule any tasks after the\n   * eventLoopRunningTime hits the deadline value, otherwise all tasks will be\n   * executed in one setImmediate batch (default).\n   *\n   * @deprecated\n   */\n  setDeadline(deadline: number) {\n    // Do nothing.\n  },\n};\n\nexport default InteractionManagerStub;\n"],"mappings":";;;;AAYA,IAAMA,SAAS,GAAGC,OAAO,CAAC,WAAW,CAAC;AAiBtC,SAASC,MAAMA,CAACC,KAAY,EAAQ;EAClCC,UAAU,CAAC,YAAM;IACf,MAAMD,KAAK;EACb,CAAC,EAAE,CAAC,CAAC;AACP;AAqDA,IAAME,sBAAsB,GAAG;EAC7BC,MAAM,EAAE;IACNC,gBAAgB,EAAE,kBAAkB;IACpCC,mBAAmB,EAAE;EACvB,CAAC;EAQDC,oBAAoB,WAApBA,oBAAoBA,CAACC,IAAW,EAO9B;IACA,IAAIC,WAAwB;IAC5B,IAAMC,OAAO,GAAG,IAAIC,OAAO,CAAC,UAAAC,OAAO,EAAI;MACrCH,WAAW,GAAGI,YAAY,CAAC,YAAM;QAC/B,IAAI,OAAOL,IAAI,KAAK,QAAQ,IAAIA,IAAI,KAAK,IAAI,EAAE;UAC7C,IAAI,OAAOA,IAAI,CAACM,GAAG,KAAK,UAAU,EAAE;YAClCN,IAAI,CAACM,GAAG,CAAC,CAAC,CAACC,IAAI,CAACH,OAAO,EAAEZ,MAAM,CAAC;UAClC,CAAC,MAAM,IAAI,OAAOQ,IAAI,CAACQ,GAAG,KAAK,UAAU,EAAE;YACzC,IAAI;cACFR,IAAI,CAACQ,GAAG,CAAC,CAAC;cACVJ,OAAO,CAAC,CAAC;YACX,CAAC,CAAC,OAAOX,KAAK,EAAE;cACdD,MAAM,CAACC,KAAK,CAAC;YACf;UACF,CAAC,MAAM;YACLD,MAAM,CAAC,IAAIiB,SAAS,CAAC,SAAST,IAAI,CAACU,IAAI,uBAAuB,CAAC,CAAC;UAClE;QACF,CAAC,MAAM,IAAI,OAAOV,IAAI,KAAK,UAAU,EAAE;UACrC,IAAI;YACFA,IAAI,CAAC,CAAC;YACNI,OAAO,CAAC,CAAC;UACX,CAAC,CAAC,OAAOX,KAAK,EAAE;YACdD,MAAM,CAACC,KAAK,CAAC;UACf;QACF,CAAC,MAAM;UACLD,MAAM,CAAC,IAAIiB,SAAS,CAAC,wBAAwB,GAAG,OAAOT,IAAI,CAAC,CAAC;QAC/D;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;IAEF,OAAO;MAELO,IAAI,EAAEL,OAAO,CAACK,IAAI,CAACI,IAAI,CAACT,OAAO,CAAC;MAChCU,MAAM,WAANA,MAAMA,CAAA,EAAG;QACPC,cAAc,CAACZ,WAAW,CAAC;MAC7B;IACF,CAAC;EACH,CAAC;EAODa,uBAAuB,WAAvBA,uBAAuBA,CAAA,EAAW;IAChC,OAAO,CAAC,CAAC;EACX,CAAC;EAODC,sBAAsB,WAAtBA,sBAAsBA,CAACC,MAAc,EAAE;IACrC1B,SAAS,CAAC,CAAC,CAAC0B,MAAM,EAAE,qDAAqD,CAAC;EAC5E,CAAC;EAKDC,WAAW,WAAXA,WAAWA,CAAA,EAAsB;IAC/B,OAAO;MACLC,MAAM,WAANA,MAAMA,CAAA,EAAG,CAAC;IACZ,CAAC;EACH,CAAC;EASDC,WAAW,WAAXA,WAAWA,CAACC,QAAgB,EAAE,CAE9B;AACF,CAAC;AAAC,IAAAC,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAEa5B,sBAAsB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}