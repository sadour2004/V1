{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar TurboModuleRegistry = _interopRequireWildcard(require(\"../../../../Libraries/TurboModule/TurboModuleRegistry\"));\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) \"default\" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }\nvar _default = exports.default = TurboModuleRegistry.getEnforcing('UIManager');","map":{"version":3,"names":["TurboModuleRegistry","_interopRequireWildcard","require","e","t","WeakMap","r","n","__esModule","o","i","f","__proto__","default","has","get","set","_t","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","_default","exports","getEnforcing"],"sources":["/Users/ayoubsadour/Desktop/APPMOBILE/MachineStatusApp/node_modules/react-native/src/private/specs_DEPRECATED/modules/NativeUIManager.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\nimport type {RootTag} from '../../../../Libraries/TurboModule/RCTExport';\nimport type {TurboModule} from '../../../../Libraries/TurboModule/RCTExport';\n\nimport * as TurboModuleRegistry from '../../../../Libraries/TurboModule/TurboModuleRegistry';\n\nexport type MeasureOnSuccessCallback = (\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  pageX: number,\n  pageY: number,\n) => void;\n\nexport type MeasureInWindowOnSuccessCallback = (\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n) => void;\n\nexport type MeasureLayoutOnSuccessCallback = (\n  left: number,\n  top: number,\n  width: number,\n  height: number,\n) => void;\n\nexport interface Spec extends TurboModule {\n  +getConstants: () => Object;\n  +createView: (\n    reactTag: number,\n    viewName: string,\n    rootTag: RootTag,\n    props: Object,\n  ) => void;\n  +updateView: (reactTag: number, viewName: string, props: Object) => void;\n  +findSubviewIn: (\n    reactTag: number,\n    point: Array<number>,\n    callback: (\n      nativeViewTag: number,\n      left: number,\n      top: number,\n      width: number,\n      height: number,\n    ) => void,\n  ) => void;\n  /**\n   * Used to call a native view method from JavaScript\n   *\n   * reactTag - Id of react view.\n   * commandID - Id of the native method that should be called.\n   * commandArgs - Args of the native method that we can pass from JS to native.\n   */\n  +dispatchViewManagerCommand: (\n    reactTag: number,\n    commandID: number, // number || string\n    commandArgs?: Array<any>,\n  ) => void;\n  /**\n   * Determines the location on screen, width, and height of the given view and\n   * returns the values via an async callback. If successful, the callback will\n   * be called with the following arguments:\n   *\n   *  - x\n   *  - y\n   *  - width\n   *  - height\n   *  - pageX\n   *  - pageY\n   *\n   * Note that these measurements are not available until after the rendering\n   * has been completed in native. If you need the measurements as soon as\n   * possible, consider using the [`onLayout`\n   * prop](docs/view.html#onlayout) instead.\n   *\n   * @deprecated Use `ref.measure` instead.\n   */\n  +measure: (reactTag: number, callback: MeasureOnSuccessCallback) => void;\n  /**\n   * Determines the location of the given view in the window and returns the\n   * values via an async callback. If the React root view is embedded in\n   * another native view, this will give you the absolute coordinates. If\n   * successful, the callback will be called with the following\n   * arguments:\n   *\n   *  - x\n   *  - y\n   *  - width\n   *  - height\n   *\n   * Note that these measurements are not available until after the rendering\n   * has been completed in native.\n   *\n   * @deprecated Use `ref.measureInWindow` instead.\n   */\n  +measureInWindow: (\n    reactTag: number,\n    callback: MeasureInWindowOnSuccessCallback,\n  ) => void;\n  +viewIsDescendantOf: (\n    reactTag: number,\n    ancestorReactTag: number,\n    callback: (result: Array<boolean>) => void,\n  ) => void;\n  /**\n   * Like [`measure()`](#measure), but measures the view relative an ancestor,\n   * specified as `relativeToNativeNode`. This means that the returned x, y\n   * are relative to the origin x, y of the ancestor view.\n   *\n   * As always, to obtain a native node handle for a component, you can use\n   * `React.findNodeHandle(component)`.\n   *\n   * @deprecated Use `ref.measureLayout` instead.\n   */\n  +measureLayout: (\n    reactTag: number,\n    ancestorReactTag: number,\n    errorCallback: (error: Object) => void,\n    callback: MeasureLayoutOnSuccessCallback,\n  ) => void;\n  +measureLayoutRelativeToParent: (\n    reactTag: number,\n    errorCallback: (error: Object) => void,\n    callback: (\n      left: number,\n      top: number,\n      width: number,\n      height: number,\n    ) => void,\n  ) => void;\n  +setJSResponder: (reactTag: number, blockNativeResponder: boolean) => void;\n  +clearJSResponder: () => void;\n  +configureNextLayoutAnimation: (\n    config: Object,\n    callback: () => void, // check what is returned here\n    errorCallback: (error: Object) => void,\n  ) => void;\n  +setChildren: (containerTag: number, reactTags: Array<number>) => void;\n  +manageChildren: (\n    containerTag: number,\n    moveFromIndices: Array<number>,\n    moveToIndices: Array<number>,\n    addChildReactTags: Array<number>,\n    addAtIndices: Array<number>,\n    removeAtIndices: Array<number>,\n  ) => void;\n\n  // Android only\n  +getConstantsForViewManager?: (viewManagerName: string) => ?Object;\n  +getDefaultEventTypes?: () => Array<string>;\n  /**\n   * Automatically animates views to their new positions when the\n   * next layout happens.\n   *\n   * A common way to use this API is to call it before calling `setState`.\n   *\n   * Note that in order to get this to work on **Android** you need to set the following flags via `UIManager`:\n   *\n   * ```js\n   * UIManager.setLayoutAnimationEnabledExperimental && UIManager.setLayoutAnimationEnabledExperimental(true);\n   * ```\n   */\n  +setLayoutAnimationEnabledExperimental?: (enabled: boolean) => void;\n  +sendAccessibilityEvent?: (reactTag: number, eventType: number) => void;\n\n  // ios only\n  +lazilyLoadView?: (name: string) => Object; // revisit return\n  +focus?: (reactTag: number) => void;\n  +blur?: (reactTag: number) => void;\n}\n\nexport default (TurboModuleRegistry.getEnforcing<Spec>('UIManager'): Spec);\n"],"mappings":";;;;AAaA,IAAAA,mBAAA,GAAAC,uBAAA,CAAAC,OAAA;AAA6F,SAAAD,wBAAAE,CAAA,EAAAC,CAAA,6BAAAC,OAAA,MAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAJ,uBAAA,YAAAA,wBAAAE,CAAA,EAAAC,CAAA,SAAAA,CAAA,IAAAD,CAAA,IAAAA,CAAA,CAAAK,UAAA,SAAAL,CAAA,MAAAM,CAAA,EAAAC,CAAA,EAAAC,CAAA,KAAAC,SAAA,QAAAC,OAAA,EAAAV,CAAA,iBAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,SAAAQ,CAAA,MAAAF,CAAA,GAAAL,CAAA,GAAAG,CAAA,GAAAD,CAAA,QAAAG,CAAA,CAAAK,GAAA,CAAAX,CAAA,UAAAM,CAAA,CAAAM,GAAA,CAAAZ,CAAA,GAAAM,CAAA,CAAAO,GAAA,CAAAb,CAAA,EAAAQ,CAAA,cAAAM,EAAA,IAAAd,CAAA,gBAAAc,EAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,EAAA,OAAAP,CAAA,IAAAD,CAAA,GAAAW,MAAA,CAAAC,cAAA,KAAAD,MAAA,CAAAE,wBAAA,CAAAnB,CAAA,EAAAc,EAAA,OAAAP,CAAA,CAAAK,GAAA,IAAAL,CAAA,CAAAM,GAAA,IAAAP,CAAA,CAAAE,CAAA,EAAAM,EAAA,EAAAP,CAAA,IAAAC,CAAA,CAAAM,EAAA,IAAAd,CAAA,CAAAc,EAAA,WAAAN,CAAA,KAAAR,CAAA,EAAAC,CAAA;AAAA,IAAAmB,QAAA,GAAAC,OAAA,CAAAX,OAAA,GA0K7Eb,mBAAmB,CAACyB,YAAY,CAAO,WAAW,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}